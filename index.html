<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Valentine's Game</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><rect x='3' y='1' width='2' height='2' fill='%23ff6b9d'/><rect x='5' y='1' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='1' width='2' height='2' fill='%23ff6b9d'/><rect x='11' y='1' width='2' height='2' fill='%23ff6b9d'/><rect x='1' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='3' y='3' width='2' height='2' fill='%23ffb3d0'/><rect x='5' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='11' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='13' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='1' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='3' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='5' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='11' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='13' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='1' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='3' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='5' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='11' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='13' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='3' y='9' width='2' height='2' fill='%23ff6b9d'/><rect x='5' y='9' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='9' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='9' width='2' height='2' fill='%23ff6b9d'/><rect x='11' y='9' width='2' height='2' fill='%23ff6b9d'/><rect x='5' y='11' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='11' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='11' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='13' width='2' height='2' fill='%23ff6b9d'/></svg>">
<script>window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };</script>
<script defer src="/_vercel/insights/script.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
  overflow: hidden;
  touch-action: none;
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
  font-family: 'Press Start 2P', monospace;
  background: #1a1a2e;
  position: fixed;
  width: 100%;
  height: 100%;
}

canvas {
  display: block;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

#ui-layer {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  z-index: 10;
}

#ui-layer > * { pointer-events: auto; }

.hidden { display: none !important; }

/* START SCREEN */
#start-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 20px;
  text-align: center;
  padding: 20px;
}

#start-screen h1 {
  font-size: clamp(18px, 5vw, 36px);
  color: #ff6b9d;
  text-shadow: 3px 3px 0 #c0507a, -1px -1px 0 #ffb3d0;
  line-height: 1.4;
}

#start-screen p {
  font-size: clamp(8px, 2.5vw, 14px);
  color: #c0507a;
  line-height: 1.6;
  text-shadow: 1px 1px 0 rgba(255,255,255,0.6);
}

.pixel-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(12px, 3vw, 20px);
  padding: 16px 32px;
  border: none;
  cursor: pointer;
  position: relative;
  color: #fff;
  background: #ff6b9d;
  box-shadow:
    0 4px 0 #c0507a,
    0 6px 0 #a0406a,
    inset 0 -2px 0 rgba(0,0,0,0.1);
  transition: transform 0.1s, box-shadow 0.1s;
  image-rendering: pixelated;
}

.pixel-btn:active {
  transform: translateY(4px);
  box-shadow:
    0 0 0 #c0507a,
    0 2px 0 #a0406a;
}

/* HUD */
#hud {
  position: fixed;
  top: 12px;
  left: 0; right: 0;
  display: flex;
  justify-content: center;
  z-index: 20;
  pointer-events: none;
}

#heart-counter {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(10px, 2.5vw, 16px);
  color: #fff;
  background: rgba(0,0,0,0.5);
  padding: 8px 16px;
  border: 2px solid #ff6b9d;
}

/* END SCREEN */
#end-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 24px;
  text-align: center;
  padding: 20px;
  width: 100%;
}

#end-screen h2 {
  font-size: clamp(14px, 4vw, 28px);
  color: #ff6b9d;
  text-shadow: 2px 2px 0 #c0507a;
  line-height: 1.5;
}

#end-screen .hearts-result {
  font-size: clamp(10px, 2.5vw, 16px);
  color: #ff6b9d;
  text-shadow: 1px 1px 0 #c0507a;
  margin-bottom: 8px;
}

#yes-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(20px, 5vw, 36px);
  padding: 24px 48px;
  width: min(80vw, 400px);
  border: none;
  cursor: pointer;
  color: #fff;
  background: #ff6b9d;
  box-shadow:
    0 6px 0 #c0507a,
    0 10px 0 #a0406a,
    0 0 30px rgba(255,107,157,0.4);
  animation: yesPulse 1s ease-in-out infinite;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
}

#yes-btn:active {
  transform: translateY(6px);
  box-shadow: 0 0 0 #c0507a, 0 4px 0 #a0406a;
}

@keyframes yesPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

#no-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: 6px;
  padding: 4px 8px;
  border: 1px solid #999;
  background: #888;
  color: #bbb;
  cursor: pointer;
  opacity: 0.5;
  margin-top: 20px;
  transition: transform 0.15s, left 0.15s, top 0.15s;
  /* Ensure minimum touch target for mobile accessibility */
  min-width: 44px;
  min-height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* RESULT SCREEN */
#result-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 20px;
  text-align: center;
  padding: 20px;
}

#result-screen h2 {
  font-size: clamp(24px, 6vw, 48px);
  line-height: 1.4;
}

#result-screen p {
  font-size: clamp(8px, 2.5vw, 14px);
  color: #ffb3d0;
  line-height: 1.6;
}

.play-again-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(8px, 2vw, 12px);
  padding: 12px 24px;
  border: none;
  cursor: pointer;
  color: #fff;
  background: #ff6b9d;
  box-shadow: 0 3px 0 #c0507a;
  margin-top: 10px;
}

.play-again-btn:active {
  transform: translateY(3px);
  box-shadow: none;
}

#sound-btn {
  position: fixed;
  top: 12px;
  right: 12px;
  z-index: 30;
  width: 40px;
  height: 40px;
  border: 2px solid #ffffff;
  background: #ff6b9d;
  box-shadow: 0 3px 0 #c0507a;
  color: #ffffff;
  cursor: pointer;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}

#sound-btn svg {
  width: 20px;
  height: 20px;
}

#sound-btn svg .speaker {
  fill: #fff;
}

#sound-btn svg .wave {
  fill: none;
  stroke: #fff;
  stroke-width: 2;
  stroke-linecap: square;
}

#sound-btn svg .mute-slash {
  display: none;
  stroke: #fff;
  stroke-width: 2.5;
  stroke-linecap: square;
}

#sound-btn.is-off svg .wave {
  opacity: 0;
}

#sound-btn.is-off svg .mute-slash {
  display: block;
}

#sound-btn:active {
  transform: translateY(3px);
  box-shadow: none;
}

#maker-credit {
  position: fixed;
  right: 10px;
  bottom: 8px;
  z-index: 5;
  pointer-events: none;
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(7px, 1.9vw, 10px);
  color: rgba(255, 245, 230, 0.9);
  text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.5);
  letter-spacing: 0.5px;
  white-space: nowrap;
  background: rgba(0, 0, 0, 0.2);
  padding: 3px 5px;
  border: 1px solid rgba(255, 255, 255, 0.15);
}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="maker-credit">crafted with love by Jayanth Putta</div>
<button id="sound-btn" onclick="toggleSound()" aria-label="Sound on" title="Sound on">
  <svg viewBox="0 0 24 24" aria-hidden="true">
    <path class="speaker" d="M3 10v4h4l5 4V6l-5 4H3z"></path>
    <path class="wave" d="M16 9c1.5 1 1.5 5 0 6"></path>
    <path class="wave" d="M19 7c2.6 2 2.6 8 0 10"></path>
    <line class="mute-slash" x1="4" y1="4" x2="20" y2="20"></line>
  </svg>
</button>

<div id="hud" class="hidden">
  <div id="heart-counter">HEARTS: 0</div>
</div>

<div id="ui-layer">
  <div id="start-screen">
    <h1>VALENTINE'S<br>GAME</h1>
    <p>Tap to jump and<br>collect hearts! ‚ù§Ô∏è</p>
    <button class="pixel-btn" id="start-btn">TAP TO START</button>
  </div>

  <div id="end-screen" class="hidden">
    <p class="hearts-result"></p>
    <h2>WILL YOU BE<br>MY VALENTINE?</h2>
    <button id="yes-btn">YES! üíñ</button>
    <button id="no-btn">no</button>
  </div>

  <div id="result-screen" class="hidden"></div>
</div>

<script>
// ============ AUDIO (on by default) ============
let soundOn = true;
let audioReady = false;
let audioCtx = null;
let masterGain = null;
let audioLoading = null;
const audioBuffers = {};
const lastPlayAt = { jump: 0, collect: 0, celebrate: 0 };
const USE_SYNTH_SFX = true;
const BGM_FILE = 'bgm.wav';
let bgBuffer = null;
let bgSource = null;
let bgGain = null;
let bgLoading = null;
const SFX_FILES = {
  jump: 'sfx-jump.wav',
  collect: 'sfx-collect.wav',
  celebrate: 'sfx-celebrate.wav'
};
const SFX_MIN_GAP_MS = {
  jump: 35,
  collect: 45,
  celebrate: 120
};

function decodeAudioCompat(ctx, arrayBuffer) {
  return new Promise((resolve, reject) => {
    const out = ctx.decodeAudioData(arrayBuffer, resolve, reject);
    if (out && typeof out.then === 'function') out.then(resolve).catch(reject);
  });
}

function ensureAudioGraph() {
  if (audioCtx) return;
  const AC = window.AudioContext || window.webkitAudioContext;
  if (!AC) return;
  audioCtx = new AC({ latencyHint: 'interactive' });
  masterGain = audioCtx.createGain();
  masterGain.gain.value = soundOn ? 1 : 0;
  masterGain.connect(audioCtx.destination);
}

function midiToFreq(midi) {
  return 440 * Math.pow(2, (midi - 69) / 12);
}

function pulseWave(freq, t, duty) {
  return ((t * freq) % 1) < duty ? 1 : -1;
}

function triWave(freq, t) {
  const p = (t * freq) % 1;
  return 4 * Math.abs(p - 0.5) - 1;
}

async function initAudio() {
  if (audioReady) return true;
  if (audioLoading) return audioLoading;
  audioLoading = (async () => {
    ensureAudioGraph();
    if (!audioCtx) return false;
    try { if (audioCtx.state !== 'running') await audioCtx.resume(); } catch (_) {}
    if (USE_SYNTH_SFX) {
      audioReady = true;
      loadBgBuffer();
      return true;
    }
    const entries = await Promise.all(Object.entries(SFX_FILES).map(async ([name, src]) => {
      try {
        const res = await fetch(src, { cache: 'force-cache' });
        if (!res.ok) return [name, null];
        const arrayBuffer = await res.arrayBuffer();
        const buffer = await decodeAudioCompat(audioCtx, arrayBuffer);
        return [name, buffer];
      } catch (_) {
        return [name, null];
      }
    }));
    entries.forEach(([name, buffer]) => { audioBuffers[name] = buffer; });
    audioReady = Object.values(audioBuffers).some(Boolean);
    loadBgBuffer();
    return audioReady;
  })().finally(() => { audioLoading = null; });
  return audioLoading;
}

function canPlayNow(name) {
  const t = performance.now();
  const minGap = SFX_MIN_GAP_MS[name] || 0;
  if (t - (lastPlayAt[name] || 0) < minGap) return false;
  lastPlayAt[name] = t;
  return true;
}

function scheduleTone(type, freqStart, freqEnd, startOffset, duration, amp) {
  if (!audioCtx || !masterGain) return;
  const tStart = audioCtx.currentTime + startOffset;
  const tEnd = tStart + duration;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(Math.max(1, freqStart), tStart);
  if (freqEnd && Math.abs(freqEnd - freqStart) > 0.01) {
    osc.frequency.exponentialRampToValueAtTime(Math.max(1, freqEnd), tEnd);
  }
  gain.gain.setValueAtTime(0.0001, tStart);
  gain.gain.exponentialRampToValueAtTime(Math.max(0.0002, amp), tStart + Math.min(0.012, duration * 0.3));
  gain.gain.exponentialRampToValueAtTime(0.0001, tEnd);
  osc.connect(gain);
  gain.connect(masterGain);
  osc.onended = () => {
    osc.disconnect();
    gain.disconnect();
  };
  osc.start(tStart);
  osc.stop(tEnd + 0.01);
}

function playSynth(name) {
  ensureAudioGraph();
  if (!audioCtx || !masterGain) return;
  if (audioCtx.state !== 'running') {
    audioCtx.resume().then(() => {
      if (soundOn) playSynth(name);
    }).catch(() => {});
    return;
  }
  if (name === 'jump') {
    scheduleTone('square', 560, 280, 0.0, 0.14, 0.11);
    scheduleTone('triangle', 860, 430, 0.0, 0.11, 0.06);
  } else if (name === 'collect') {
    scheduleTone('square', 1046, 1046, 0.0, 0.065, 0.11);
    scheduleTone('triangle', 1318, 1318, 0.055, 0.09, 0.13);
  } else {
    scheduleTone('square', 784, 784, 0.0, 0.12, 0.11);
    scheduleTone('square', 988, 988, 0.08, 0.12, 0.11);
    scheduleTone('triangle', 1174, 1174, 0.16, 0.14, 0.13);
    scheduleTone('triangle', 1568, 1568, 0.28, 0.22, 0.12);
  }
}

function playSound(name) {
  if (!soundOn) return;
  if (USE_SYNTH_SFX) {
    if (!canPlayNow(name)) return;
    playSynth(name);
    return;
  }
  if (!audioReady) {
    initAudio();
    if (!canPlayNow(name)) return;
    playSynth(name);
    return;
  }
  const buffer = audioBuffers[name];
  if (!buffer || !audioCtx || !masterGain) {
    if (!canPlayNow(name)) return;
    playSynth(name);
    return;
  }
  if (audioCtx.state !== 'running') {
    audioCtx.resume().then(() => {
      if (soundOn) playSound(name);
    }).catch(() => {});
    return;
  }
  if (!canPlayNow(name)) return;
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  const gain = audioCtx.createGain();
  gain.gain.value = name === 'celebrate' ? 0.9 : 0.75;
  source.connect(gain);
  gain.connect(masterGain);
  source.start(0);
}
function sfxJump() { playSound('jump'); }
function sfxCollect() { playSound('collect'); }
function sfxCelebrate() { playSound('celebrate'); }

function buildFallbackBgBuffer() {
  ensureAudioGraph();
  if (!audioCtx || bgBuffer) return;
  const sampleRate = audioCtx.sampleRate;
  const duration = 8;
  const frameCount = Math.floor(sampleRate * duration);
  const buffer = audioCtx.createBuffer(2, frameCount, sampleRate);
  const left = buffer.getChannelData(0);
  const right = buffer.getChannelData(1);
  const chordRoots = [60, 57, 53, 55]; // C, Am, F, G
  const arp = [0, 4, 7, 12, 7, 4, 2, 4];
  const bassStep = [0, 0, 7, 0, 0, 0, 5, 0];
  const stepSec = 0.25;
  let noiseState = 2463534242 >>> 0;
  let prevL = 0;
  let prevR = 0;
  for (let i = 0; i < frameCount; i++) {
    const t = i / sampleRate;
    const step = Math.floor(t / stepSec);
    const chordIdx = Math.floor(step / 8) % chordRoots.length;
    const stepInChord = step % 8;
    const local = (t - step * stepSec) / stepSec;
    const leadFreq = midiToFreq(chordRoots[chordIdx] + arp[stepInChord] + 12);
    const bassFreq = midiToFreq(chordRoots[chordIdx] - 12 + bassStep[stepInChord]);
    const padFreq = midiToFreq(chordRoots[chordIdx] + 7);
    const envLead = Math.pow(1 - local, 1.8);
    const envBass = Math.pow(1 - local, 2.4);
    const lead = (pulseWave(leadFreq, t, 0.24) * 0.08 + pulseWave(leadFreq * 2, t, 0.14) * 0.025) * envLead;
    const bass = triWave(bassFreq, t) * 0.07 * envBass;
    const pad = Math.sin(2 * Math.PI * padFreq * t) * 0.02;
    let hat = 0;
    if ((step % 2) === 1 && local < 0.07) {
      noiseState = (noiseState * 1664525 + 1013904223) >>> 0;
      const noise = (noiseState / 4294967295) * 2 - 1;
      hat = noise * (1 - local / 0.07) * 0.015;
    }
    let l = lead + bass + pad + hat;
    let r = lead * 0.9 + bass * 1.05 + pad - hat * 0.55;
    l = l * 0.86 + prevL * 0.14;
    r = r * 0.86 + prevR * 0.14;
    prevL = l;
    prevR = r;
    left[i] = Math.max(-1, Math.min(1, l));
    right[i] = Math.max(-1, Math.min(1, r));
  }
  const crossfade = Math.min(2048, Math.floor(frameCount / 12));
  for (let i = 0; i < crossfade; i++) {
    const a = i / crossfade;
    left[i] = left[i] * a + left[frameCount - crossfade + i] * (1 - a);
    right[i] = right[i] * a + right[frameCount - crossfade + i] * (1 - a);
  }
  bgBuffer = buffer;
}

async function loadBgBuffer() {
  if (bgBuffer) return bgBuffer;
  if (bgLoading) return bgLoading;
  bgLoading = (async () => {
    ensureAudioGraph();
    if (!audioCtx) return null;
    try {
      const res = await fetch(BGM_FILE, { cache: 'force-cache' });
      if (res.ok) {
        const arrayBuffer = await res.arrayBuffer();
        const decoded = await decodeAudioCompat(audioCtx, arrayBuffer);
        if (decoded) {
          bgBuffer = decoded;
          return bgBuffer;
        }
      }
    } catch (_) {}
    buildFallbackBgBuffer();
    return bgBuffer;
  })().finally(() => { bgLoading = null; });
  return bgLoading;
}

function startBgMusic() {
  if (!soundOn) return;
  ensureAudioGraph();
  if (!audioCtx || !masterGain) return;
  if (typeof STATE !== 'undefined' && state !== STATE.PLAYING) return;
  if (bgSource) return;
  if (audioCtx.state !== 'running') {
    audioCtx.resume().then(() => {
      if (soundOn) startBgMusic();
    }).catch(() => {});
    return;
  }
  if (!bgBuffer) {
    loadBgBuffer().then(() => {
      if (soundOn) startBgMusic();
    }).catch(() => {});
    return;
  }
  const source = audioCtx.createBufferSource();
  source.buffer = bgBuffer;
  source.loop = true;
  const gain = audioCtx.createGain();
  gain.gain.value = 0.14;
  source.connect(gain);
  gain.connect(masterGain);
  source.onended = () => {
    if (bgSource === source) bgSource = null;
  };
  source.start(0);
  bgSource = source;
  bgGain = gain;
}

function stopBgMusic() {
  if (bgSource) {
    try { bgSource.stop(); } catch (_) {}
    bgSource.disconnect();
    bgSource = null;
  }
  if (bgGain) {
    bgGain.disconnect();
    bgGain = null;
  }
}

function updateSoundButton() {
  const btn = document.getElementById('sound-btn');
  if (!btn) return;
  btn.classList.toggle('is-off', !soundOn);
  const label = soundOn ? 'Sound on' : 'Sound off';
  btn.setAttribute('aria-label', label);
  btn.title = label;
}

function toggleSound() {
  soundOn = !soundOn;
  if (soundOn) {
    initAudio();
    if (typeof STATE !== 'undefined' && state === STATE.PLAYING) startBgMusic();
  } else {
    stopBgMusic();
  }
  if (masterGain && audioCtx) {
    const target = soundOn ? 1 : 0;
    masterGain.gain.setTargetAtTime(target, audioCtx.currentTime, 0.01);
  }
  updateSoundButton();
}

document.addEventListener('visibilitychange', () => {
  if (!soundOn || !audioCtx) return;
  if (document.visibilityState === 'visible' && audioCtx.state !== 'running') {
    audioCtx.resume().then(() => {
      if (typeof STATE !== 'undefined' && state === STATE.PLAYING) startBgMusic();
    }).catch(() => {});
  }
});

if (soundOn) initAudio();
updateSoundButton();

// ============ CANVAS SETUP ============
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W, H, scale;

function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
  scale = Math.min(W, H) / 400;
}
resize();
window.addEventListener('resize', () => { resize(); skyCacheH = 0; });

// ============ GAME STATE ============
const STATE = { START: 0, PLAYING: 1, ENDING: 2, END: 3, RESULT: 4 };
let state = STATE.START;
let heartsCollected = 0;
let totalHearts = 10;
let gameTimer = 0;
const GAME_DURATION = 5000;
// Scale scroll distance to screen width so it feels right on both phone and desktop
// Phone (~375px) -> ~750px, Desktop (~1400px) -> ~1200px
const SCROLL_DIST = Math.max(700, Math.min(1200, W * 1.8));
let lastTime = 0;

// ============ CHARACTER ============
const player = {
  x: 0, y: 0, vy: 0, groundY: 0,
  width: 28, height: 32,
  jumping: false, frame: 0, frameTimer: 0,
  eyeBlink: 0
};

// ============ HEARTS ============
let hearts = [];
let particles = [];

// ============ CLOUDS ============
let clouds = [];
function initClouds() {
  clouds = [];
  for (let i = 0; i < 6; i++) {
    clouds.push({
      x: Math.random() * W * 1.5,
      y: 30 + Math.random() * (H * 0.35),
      w: 40 + Math.random() * 60,
      speed: 15 + Math.random() * 20,
      opacity: 0.3 + Math.random() * 0.3
    });
  }
}

// ============ GROUND ============
let groundOffset = 0;

// ============ CONFETTI ============
let confetti = [];

// ============ INIT / START ============
function initGame() {
  heartsCollected = 0;
  gameTimer = 0;
  player.x = W * 0.15;
  player.groundY = H - 80 * scale;
  player.y = player.groundY;
  player.vy = 0;
  player.jumping = false;
  player.frame = 0;
  hearts = [];
  particles = [];
  confetti = [];
  groundOffset = 0;
  initClouds();
  spawnHearts();
  updateHUD();
}

function spawnHearts() {
  hearts = [];
  // Use a fixed scroll distance so mobile and desktop feel the same pace
  const totalScrollDist = SCROLL_DIST;
  const startOffset = totalScrollDist * 0.08;
  const endOffset = totalScrollDist * 0.92;
  const spacing = (endOffset - startOffset) / totalHearts;
  for (let i = 0; i < totalHearts; i++) {
    const baseX = player.x + startOffset + i * spacing;
    const tier = Math.random();
    let yPos;
    if (tier < 0.35) yPos = player.groundY - 20 * scale;
    else if (tier < 0.7) yPos = player.groundY - 70 * scale;
    else yPos = player.groundY - 120 * scale;
    hearts.push({
      x: baseX + (Math.random() - 0.5) * 40,
      y: yPos,
      size: 14 * scale,
      alive: true,
      bobOffset: Math.random() * Math.PI * 2,
      popTimer: 0
    });
  }
}

function updateHUD() {
  document.getElementById('heart-counter').textContent = `HEARTS: ${heartsCollected}`;
}

// ============ DRAWING HELPERS ============
function drawPixelRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(Math.round(x), Math.round(y), Math.round(w), Math.round(h));
}

// Pre-render heart to an offscreen canvas (drawn once, stamped many times)
const heartCache = {};
function getHeartCanvas(size, color) {
  const key = size + color;
  if (heartCache[key]) return heartCache[key];
  const s = size / 8;
  const w = Math.ceil(s * 9), h = Math.ceil(s * 6);
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const hctx = c.getContext('2d');
  hctx.fillStyle = color;
  const rows = [
    [-3,-1,-2,-1,1,-1,2,-1],
    [-4,0,-3,0,-2,0,-1,0,0,0,1,0,2,0,3,0],
    [-4,1,-3,1,-2,1,-1,1,0,1,1,1,2,1,3,1],
    [-3,2,-2,2,-1,2,0,2,1,2,2,2],
    [-2,3,-1,3,0,3,1,3],
    [-1,4,0,4]
  ];
  const ox = 4 * s, oy = s;
  rows.forEach(row => {
    for (let i = 0; i < row.length; i += 2)
      hctx.fillRect(Math.round(ox + row[i]*s), Math.round(oy + row[i+1]*s), Math.ceil(s), Math.ceil(s));
  });
  heartCache[key] = { canvas: c, ox: ox, oy: oy };
  return heartCache[key];
}

function drawHeart(cx, cy, size, color) {
  const h = getHeartCanvas(size, color);
  ctx.drawImage(h.canvas, Math.round(cx - h.ox), Math.round(cy - h.oy));
}

function drawCharacter(x, y) {
  const s = scale * 1.2;
  const px = Math.round(x);
  const py = Math.round(y);

  // Body (pink rounded)
  drawPixelRect(px - 10*s, py - 24*s, 20*s, 24*s, '#ff9bc5');
  // Body highlight
  drawPixelRect(px - 8*s, py - 22*s, 4*s, 8*s, '#ffb8d8');

  // Eyes
  const blinkOpen = player.eyeBlink < 0.9;
  if (blinkOpen) {
    drawPixelRect(px - 6*s, py - 18*s, 4*s, 5*s, '#fff');
    drawPixelRect(px + 2*s, py - 18*s, 4*s, 5*s, '#fff');
    drawPixelRect(px - 4*s, py - 17*s, 2*s, 3*s, '#222');
    drawPixelRect(px + 4*s, py - 17*s, 2*s, 3*s, '#222');
  } else {
    drawPixelRect(px - 6*s, py - 16*s, 5*s, 2*s, '#222');
    drawPixelRect(px + 2*s, py - 16*s, 5*s, 2*s, '#222');
  }

  // Cheeks
  drawPixelRect(px - 10*s, py - 12*s, 4*s, 3*s, '#ff7eb3');
  drawPixelRect(px + 6*s, py - 12*s, 4*s, 3*s, '#ff7eb3');

  // Mouth (smile)
  drawPixelRect(px - 2*s, py - 8*s, 5*s, 2*s, '#c0507a');

  // Feet
  const bounce = player.jumping ? 0 : Math.sin(player.frame * 0.3) * 3 * s;
  drawPixelRect(px - 8*s, py + bounce, 6*s, 4*s, '#ff7eb3');
  drawPixelRect(px + 2*s, py - bounce, 6*s, 4*s, '#ff7eb3');

  // Heart antenna
  drawPixelRect(px, py - 30*s, 2*s, 6*s, '#c0507a');
  drawHeart(px + 1*s, py - 36*s, 8*s, '#ff6b9d');
}

function drawGround() {
  const groundTop = H - 60 * scale;
  // Main ground
  ctx.fillStyle = '#8bac0f';
  ctx.fillRect(0, groundTop, W, H - groundTop);
  // Dark edge
  ctx.fillStyle = '#6d8b0a';
  ctx.fillRect(0, groundTop, W, 4 * scale);
  // Grass tufts
  ctx.fillStyle = '#9bbc0f';
  const tileW = 24 * scale;
  const off = groundOffset % tileW;
  for (let x = -tileW + off; x < W + tileW; x += tileW) {
    ctx.fillRect(Math.round(x), groundTop - 3*scale, 8*scale, 3*scale);
  }
}

// Cache the sky gradient as an offscreen canvas (recreated on resize)
let skyCache = null;
let skyCacheH = 0;
function getSkyCanvas() {
  if (skyCache && skyCacheH === H) return skyCache;
  skyCache = document.createElement('canvas');
  skyCache.width = 1; skyCache.height = H;
  const sctx = skyCache.getContext('2d');
  const grad = sctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#b8d4ff');
  grad.addColorStop(0.6, '#e2eeff');
  grad.addColorStop(1, '#ffdef2');
  sctx.fillStyle = grad;
  sctx.fillRect(0, 0, 1, H);
  skyCacheH = H;
  return skyCache;
}

function drawBackground(dt) {
  ctx.drawImage(getSkyCanvas(), 0, 0, 1, H, 0, 0, W, H);

  // Clouds
  clouds.forEach(c => {
    if (state === STATE.PLAYING) c.x -= c.speed * dt;
    if (c.x + c.w < -20) { c.x = W + 40; c.y = 30 + Math.random() * (H*0.35); }
    ctx.fillStyle = `rgba(255,255,255,${c.opacity})`;
    const cw = c.w * scale * 0.5;
    const ch = cw * 0.5;
    roundRect(c.x, c.y, cw, ch, ch * 0.4);
  });
}

function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.fill();
}

// ============ PARTICLES ============
function spawnParticles(x, y) {
  for (let i = 0; i < 8; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 200,
      vy: (Math.random() - 0.5) * 200 - 80,
      life: 0.6,
      maxLife: 0.6,
      size: (3 + Math.random() * 4) * scale,
      color: Math.random() > 0.5 ? '#ff6b9d' : '#ffb3d0'
    });
  }
}

function spawnConfetti() {
  for (let i = 0; i < 80; i++) {
    confetti.push({
      x: W * 0.5 + (Math.random() - 0.5) * W * 0.3,
      y: -20 - Math.random() * H * 0.5,
      vx: (Math.random() - 0.5) * 100,
      vy: 80 + Math.random() * 200,
      size: (4 + Math.random() * 8) * scale,
      color: ['#ff6b9d','#ffb3d0','#ff9bc5','#c0507a','#fff','#ffd700'][Math.floor(Math.random()*6)],
      rot: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 8
    });
  }
}

// ============ UPDATE ============
function update(dt) {
  if (state === STATE.PLAYING) {
    gameTimer += dt * 1000;

    // Move world
    const speed = (SCROLL_DIST / (GAME_DURATION / 1000)) * dt;
    groundOffset -= speed;

    // Move hearts toward player
    hearts.forEach(h => { if (h.alive) h.x -= speed; });

    // Player physics
    if (player.jumping) {
      player.vy += 1800 * scale * dt;
      player.y += player.vy * dt;
      if (player.y >= player.groundY) {
        player.y = player.groundY;
        player.vy = 0;
        player.jumping = false;
      }
    }

    // Player animation
    player.frameTimer += dt;
    if (player.frameTimer > 0.08) { player.frame++; player.frameTimer = 0; }
    player.eyeBlink = (Math.sin(performance.now() * 0.003) + 1) * 0.5;
    if (player.eyeBlink > 0.95) player.eyeBlink = 1;
    else player.eyeBlink = 0;

    // Heart collision
    hearts.forEach(h => {
      if (!h.alive) return;
      const bobY = h.y + Math.sin(performance.now() * 0.004 + h.bobOffset) * 6 * scale;
      const dx = player.x - h.x;
      const dy = (player.y - 12*scale) - bobY;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < 30 * scale) {
        h.alive = false;
        heartsCollected++;
        updateHUD();
        sfxCollect();
        spawnParticles(h.x, bobY);
      }
    });

    // Timer check
    if (gameTimer >= GAME_DURATION) {
      state = STATE.ENDING;
      setTimeout(showEndScreen, 600);
    }
  }

  // Update particles
  particles = particles.filter(p => {
    p.life -= dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 300 * dt;
    return p.life > 0;
  });

  // Update confetti
  confetti.forEach(c => {
    c.x += c.vx * dt;
    c.y += c.vy * dt;
    c.rot += c.rotSpeed * dt;
  });
  confetti = confetti.filter(c => c.y < H + 50);
}

// ============ RENDER ============
function render() {
  // Only draw background on start/end screens (skip game objects)
  const playing = state === STATE.PLAYING || state === STATE.ENDING;
  const hasEffects = particles.length > 0 || confetti.length > 0;

  // Skip rendering entirely if nothing is animating on static screens
  if (!playing && !hasEffects && (state === STATE.START || state === STATE.END)) {
    // Just draw background once, then stop
    if (!render._bgDrawn || render._bgState !== state) {
      drawBackground(0);
      drawGround();
      render._bgDrawn = true;
      render._bgState = state;
    }
    return;
  }
  render._bgDrawn = false;

  drawBackground(1/60);
  drawGround();

  if (playing) {
    // Draw hearts
    hearts.forEach(h => {
      if (!h.alive) return;
      const bobY = h.y + Math.sin(performance.now() * 0.004 + h.bobOffset) * 6 * scale;
      drawHeart(h.x, bobY, h.size, '#ff6b9d');
    });

    // Draw character
    drawCharacter(player.x, player.y);
  }

  // Particles
  if (particles.length > 0) {
    particles.forEach(p => {
      ctx.globalAlpha = p.life / p.maxLife;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x | 0, p.y | 0, p.size, p.size);
    });
    ctx.globalAlpha = 1;
  }

  // Confetti ‚Äî batch by color to reduce state changes
  if (confetti.length > 0) {
    confetti.forEach(c => {
      ctx.fillStyle = c.color;
      ctx.fillRect((c.x - c.size/2) | 0, (c.y - c.size/4) | 0, c.size, c.size/2);
    });
  }
}

// ============ GAME LOOP ============
function loop(time) {
  const dt = Math.min((time - lastTime) / 1000, 0.05);
  lastTime = time;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

// ============ INPUT ============
function handleTap(e) {
  e.preventDefault();
  if (state === STATE.PLAYING && !player.jumping) {
    player.jumping = true;
    player.vy = -550 * scale;
    sfxJump();
  }
}

canvas.addEventListener('pointerdown', handleTap);

// ============ SCREENS ============
function showEndScreen() {
  state = STATE.END;
  stopBgMusic();
  document.getElementById('hud').classList.add('hidden');
  const endScreen = document.getElementById('end-screen');
  endScreen.classList.remove('hidden');
  document.getElementById('start-screen').classList.add('hidden');
  endScreen.querySelector('.hearts-result').textContent = `You collected ${heartsCollected} hearts!`;
}

document.getElementById('start-btn').addEventListener('click', () => {
  // Start gameplay; audio remains opt-in via sound toggle
  if (soundOn) initAudio();
  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
  state = STATE.PLAYING;
  initGame();
  startBgMusic();
});

document.getElementById('yes-btn').addEventListener('click', () => {
  sfxCelebrate();
  spawnConfetti();
  setTimeout(spawnConfetti, 400);
  document.getElementById('end-screen').classList.add('hidden');
  const result = document.getElementById('result-screen');
  result.classList.remove('hidden');
  result.innerHTML = `
    <h2 style="color:#ff6b9d;text-shadow:2px 2px 0 #c0507a">YAY!</h2>
    <p style="color:#c0507a;font-size:clamp(10px,3vw,16px);margin-top:10px;text-shadow:1px 1px 0 rgba(255,255,255,0.5)">Happy Valentine's Day! üíñ</p>
    <button class="play-again-btn" onclick="location.reload()">PLAY AGAIN</button>
  `;
  state = STATE.RESULT;
  localStorage.setItem('valentine_yes', 'true');
});

// NO button - always dodges, can never be clicked
const noBtn = document.getElementById('no-btn');
const yesBtn = document.getElementById('yes-btn');
let noAttempts = 0;

function dodgeNo(e) {
  if (e) { e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation(); }
  noAttempts++;

  // Make YES button grow with each attempt
  const growScale = 1 + noAttempts * 0.08;
  yesBtn.style.transform = `scale(${growScale})`;
  yesBtn.style.animation = 'none';
  void yesBtn.offsetHeight; // reflow
  yesBtn.style.animation = 'yesPulse 0.6s ease-in-out infinite';

  // Teleport to a random spot, keeping it on screen
  const pad = 30;
  const nx = pad + Math.random() * (W - pad * 2 - 60);
  const ny = pad + Math.random() * (H - pad * 2 - 30);
  noBtn.style.position = 'fixed';
  noBtn.style.left = nx + 'px';
  noBtn.style.top = ny + 'px';
  noBtn.style.zIndex = '100';
  // Shrink it further each time (min 0.3)
  const shrink = Math.max(0.3, 1 - noAttempts * 0.08);
  noBtn.style.transform = `scale(${shrink})`;
}

// Block click entirely ‚Äî dodge happens on pointer/touch events only
noBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); });
// Desktop hover
noBtn.addEventListener('pointerenter', dodgeNo);
// Mobile tap ‚Äî touchstart fires before click so we dodge first
noBtn.addEventListener('touchstart', dodgeNo, { passive: false });
// Fallback for non-touch pointer devices
noBtn.addEventListener('pointerdown', dodgeNo);

// ============ BOOT ============
initClouds();
lastTime = performance.now();
requestAnimationFrame(loop);
</script>
</body>
</html>
