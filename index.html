<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Valentine's Game</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><rect x='3' y='1' width='2' height='2' fill='%23ff6b9d'/><rect x='5' y='1' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='1' width='2' height='2' fill='%23ff6b9d'/><rect x='11' y='1' width='2' height='2' fill='%23ff6b9d'/><rect x='1' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='3' y='3' width='2' height='2' fill='%23ffb3d0'/><rect x='5' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='11' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='13' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='1' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='3' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='5' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='11' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='13' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='1' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='3' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='5' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='11' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='13' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='3' y='9' width='2' height='2' fill='%23ff6b9d'/><rect x='5' y='9' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='9' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='9' width='2' height='2' fill='%23ff6b9d'/><rect x='11' y='9' width='2' height='2' fill='%23ff6b9d'/><rect x='5' y='11' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='11' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='11' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='13' width='2' height='2' fill='%23ff6b9d'/></svg>">
<script>window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };</script>
<script defer src="/_vercel/insights/script.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
  overflow: hidden;
  touch-action: none;
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
  font-family: 'Press Start 2P', monospace;
  background: #1a1a2e;
  position: fixed;
  width: 100%;
  height: 100%;
}

canvas {
  display: block;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

#ui-layer {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  z-index: 10;
}

#ui-layer > * { pointer-events: auto; }

.hidden { display: none !important; }

/* START SCREEN */
#start-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 20px;
  text-align: center;
  padding: 20px;
}

#start-screen h1 {
  font-size: clamp(18px, 5vw, 36px);
  color: #ff6b9d;
  text-shadow: 3px 3px 0 #c0507a, -1px -1px 0 #ffb3d0;
  line-height: 1.4;
}

#start-screen p {
  font-size: clamp(8px, 2.5vw, 14px);
  color: #c0507a;
  line-height: 1.6;
  text-shadow: 1px 1px 0 rgba(255,255,255,0.6);
}

.pixel-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(12px, 3vw, 20px);
  padding: 16px 32px;
  border: none;
  cursor: pointer;
  position: relative;
  color: #fff;
  background: #ff6b9d;
  box-shadow:
    0 4px 0 #c0507a,
    0 6px 0 #a0406a,
    inset 0 -2px 0 rgba(0,0,0,0.1);
  transition: transform 0.1s, box-shadow 0.1s;
  image-rendering: pixelated;
}

.pixel-btn:active {
  transform: translateY(4px);
  box-shadow:
    0 0 0 #c0507a,
    0 2px 0 #a0406a;
}

/* HUD */
#hud {
  position: fixed;
  top: 12px;
  left: 0; right: 0;
  display: flex;
  justify-content: center;
  z-index: 20;
  pointer-events: none;
}

#heart-counter {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(10px, 2.5vw, 16px);
  color: #fff;
  background: rgba(0,0,0,0.5);
  padding: 8px 16px;
  border: 2px solid #ff6b9d;
}

/* END SCREEN */
#end-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 24px;
  text-align: center;
  padding: 20px;
  width: 100%;
}

#end-screen h2 {
  font-size: clamp(14px, 4vw, 28px);
  color: #ff6b9d;
  text-shadow: 2px 2px 0 #c0507a;
  line-height: 1.5;
}

#end-screen .hearts-result {
  font-size: clamp(10px, 2.5vw, 16px);
  color: #ff6b9d;
  text-shadow: 1px 1px 0 #c0507a;
  margin-bottom: 8px;
}

#yes-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(20px, 5vw, 36px);
  padding: 24px 48px;
  width: min(80vw, 400px);
  border: none;
  cursor: pointer;
  color: #fff;
  background: #ff6b9d;
  box-shadow:
    0 6px 0 #c0507a,
    0 10px 0 #a0406a,
    0 0 30px rgba(255,107,157,0.4);
  animation: yesPulse 1s ease-in-out infinite;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
}

#yes-btn:active {
  transform: translateY(6px);
  box-shadow: 0 0 0 #c0507a, 0 4px 0 #a0406a;
}

@keyframes yesPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

#no-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: 6px;
  padding: 4px 8px;
  border: 1px solid #999;
  background: #888;
  color: #bbb;
  cursor: pointer;
  opacity: 0.5;
  margin-top: 20px;
  transition: transform 0.15s, left 0.15s, top 0.15s;
  /* Ensure minimum touch target for mobile accessibility */
  min-width: 44px;
  min-height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* RESULT SCREEN */
#result-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 20px;
  text-align: center;
  padding: 20px;
}

#result-screen h2 {
  font-size: clamp(24px, 6vw, 48px);
  line-height: 1.4;
}

#result-screen p {
  font-size: clamp(8px, 2.5vw, 14px);
  color: #ffb3d0;
  line-height: 1.6;
}

.play-again-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(8px, 2vw, 12px);
  padding: 12px 24px;
  border: none;
  cursor: pointer;
  color: #fff;
  background: #ff6b9d;
  box-shadow: 0 3px 0 #c0507a;
  margin-top: 10px;
}

.play-again-btn:active {
  transform: translateY(3px);
  box-shadow: none;
}

#sound-btn {
  position: fixed;
  top: 12px;
  right: 12px;
  z-index: 30;
  width: 40px;
  height: 40px;
  border: 2px solid #fff;
  background: rgba(255,107,157,0.92);
  box-shadow: 0 3px 0 #c0507a;
  cursor: pointer;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}

#sound-btn svg {
  width: 20px;
  height: 20px;
}

#sound-btn .spk { fill: #fff; }
#sound-btn .wave {
  fill: none;
  stroke: #fff;
  stroke-width: 2;
  stroke-linecap: square;
}
#sound-btn .mute {
  display: none;
  stroke: #fff;
  stroke-width: 2.5;
  stroke-linecap: square;
}
#sound-btn.is-off .wave { opacity: 0; }
#sound-btn.is-off .mute { display: block; }

#sound-btn:active {
  transform: translateY(3px);
  box-shadow: none;
}

#maker-credit {
  position: fixed;
  right: 10px;
  bottom: 8px;
  z-index: 12;
  pointer-events: none;
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(6px, 1.6vw, 9px);
  color: rgba(255, 245, 230, 0.95);
  text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.6);
  background: rgba(0, 0, 0, 0.28);
  border: 1px solid rgba(255, 255, 255, 0.2);
  padding: 2px 4px;
  letter-spacing: 0.4px;
  white-space: nowrap;
}

</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="maker-credit">made with love by Jayanth Putta</div>
<button id="sound-btn" onclick="toggleSound()" aria-label="Sound on" title="Sound on">
  <svg viewBox="0 0 24 24" aria-hidden="true">
    <path class="spk" d="M3 10v4h4l5 4V6l-5 4H3z"></path>
    <path class="wave" d="M16 9c1.5 1 1.5 5 0 6"></path>
    <path class="wave" d="M19 7c2.6 2 2.6 8 0 10"></path>
    <line class="mute" x1="4" y1="4" x2="20" y2="20"></line>
  </svg>
</button>

<div id="hud" class="hidden">
  <div id="heart-counter">HEARTS: 0</div>
</div>

<div id="ui-layer">
  <div id="start-screen">
    <h1>VALENTINE'S<br>GAME</h1>
    <p>Tap to jump and<br>collect hearts! ‚ù§Ô∏è</p>
    <button class="pixel-btn" id="start-btn">TAP TO START</button>
  </div>

  <div id="end-screen" class="hidden">
    <p class="hearts-result"></p>
    <h2>WILL YOU BE<br>MY VALENTINE?</h2>
    <button id="yes-btn">YES! üíñ</button>
    <button id="no-btn">no</button>
  </div>

  <div id="result-screen" class="hidden"></div>
</div>

<script>
// ============ AUDIO (on by default) ============
let soundOn = true;
let audioReady = false;
let audioCtx = null;
let masterGain = null;
let audioLoading = null;
let audioUnlocked = false;
let audioPriming = null;
let outputRoutePrimed = false;
let bgAudioEl = null;
let bgPlayPromise = null;
let bgmWanted = false;
const AUDIO_DIAG_ENABLED = false;
let audioDiagLast = 'boot';
let audioDiagErr = '';
let audioDiagGestureCount = 0;
let audioDiagHidden = false;
const audioBuffers = {};
const lastPlayAt = { jump: 0, collect: 0, celebrate: 0 };
const BGM_FILE = 'bgm.wav';
const BGM_VOLUME_ON = 0.68;
const SFX_FILES = {
  jump: 'sfx-jump.wav',
  collect: 'sfx-collect.wav',
  celebrate: 'sfx-celebrate.wav'
};
const SFX_MIN_GAP_MS = {
  jump: 35,
  collect: 45,
  celebrate: 120
};

function decodeAudioCompat(ctx, arrayBuffer) {
  return new Promise((resolve, reject) => {
    const out = ctx.decodeAudioData(arrayBuffer, resolve, reject);
    if (out && typeof out.then === 'function') out.then(resolve).catch(reject);
  });
}

function setAudioDiag(status, err) {
  audioDiagLast = status;
  if (err) audioDiagErr = String(err && err.message ? err.message : err);
}

function getBgmState() {
  if (!bgAudioEl) return 'empty';
  if (bgPlayPromise) return 'starting';
  if (!bgAudioEl.paused) return 'playing';
  if (bgAudioEl.readyState >= 3) return 'ready';
  return 'loading';
}

function renderAudioDiag() {
  if (!AUDIO_DIAG_ENABLED) return;
  const panel = document.getElementById('audio-diag');
  const controls = document.getElementById('audio-debug-controls');
  if (!panel) return;
  if (audioDiagHidden) {
    panel.style.display = 'none';
    if (controls) controls.style.display = 'none';
    return;
  }
  panel.style.display = 'block';
  if (controls) controls.style.display = 'flex';
  const ctxState = audioCtx ? audioCtx.state : 'none';
  const bgState = getBgmState();
  const mg = masterGain ? masterGain.gain.value.toFixed(2) : '-';
  const bgVol = bgAudioEl ? bgAudioEl.volume.toFixed(2) : '-';
  panel.textContent =
`audio:${soundOn ? 'on' : 'off'}  ctx:${ctxState}
unlock:${audioUnlocked ? 'yes' : 'no'}  ready:${audioReady ? 'yes' : 'no'}
bgm:${bgState}  want:${bgmWanted ? 'yes' : 'no'}
gain:${mg}  bgvol:${bgVol}
gestures:${audioDiagGestureCount}
last:${audioDiagLast}
err:${audioDiagErr || '-'}`;
}

function ensureAudioGraph() {
  if (audioCtx) return;
  const AC = window.AudioContext || window.webkitAudioContext;
  if (!AC) return;
  audioCtx = new AC({ latencyHint: 'interactive' });
  masterGain = audioCtx.createGain();
  masterGain.gain.value = soundOn ? 1 : 0;
  masterGain.connect(audioCtx.destination);
  setAudioDiag('graph-created');
  renderAudioDiag();
}

function ensureBgAudio() {
  if (bgAudioEl) return bgAudioEl;
  const el = new Audio(BGM_FILE);
  el.preload = 'auto';
  el.loop = true;
  el.playsInline = true;
  el.volume = soundOn ? BGM_VOLUME_ON : 0;
  el.addEventListener('playing', () => {
    setAudioDiag('bg-playing');
    renderAudioDiag();
  });
  el.addEventListener('pause', () => {
    setAudioDiag(bgmWanted ? 'bg-paused' : 'bg-stopped');
    renderAudioDiag();
  });
  el.addEventListener('error', () => {
    const code = el.error ? el.error.code : 'unknown';
    setAudioDiag('bg-error', 'code ' + code);
    renderAudioDiag();
  });
  el.load();
  bgAudioEl = el;
  setAudioDiag('bg-created');
  renderAudioDiag();
  return bgAudioEl;
}

async function ensureAudioUnlocked() {
  ensureAudioGraph();
  if (!audioCtx) { setAudioDiag('no-audio-context'); renderAudioDiag(); return false; }
  if (audioCtx.state !== 'running') {
    setAudioDiag('resume-attempt');
    try { await audioCtx.resume(); } catch (e) { setAudioDiag('resume-failed', e); renderAudioDiag(); }
  }
  if (audioCtx.state !== 'running') { setAudioDiag('resume-not-running'); renderAudioDiag(); return false; }
  if (masterGain) masterGain.gain.setValueAtTime(soundOn ? 1 : 0, audioCtx.currentTime);
  if (!audioUnlocked && masterGain) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    gain.gain.value = 0.0001;
    osc.connect(gain);
    gain.connect(masterGain);
    const t0 = audioCtx.currentTime;
    osc.start(t0);
    osc.stop(t0 + 0.01);
    audioUnlocked = true;
    setAudioDiag('unlock-tick');
    renderAudioDiag();
  }
  setAudioDiag('unlocked');
  renderAudioDiag();
  return true;
}

function ensureSfxLoading() {
  if (audioReady || audioLoading) return;
  initAudio().catch(() => {});
}

async function startBgMusic(reason = 'bg-start') {
  bgmWanted = true;
  if (!soundOn) {
    setAudioDiag('bg-muted');
    renderAudioDiag();
    return false;
  }
  const bg = ensureBgAudio();
  bg.volume = BGM_VOLUME_ON;
  if (!bg.paused && !bg.ended) {
    setAudioDiag('bg-playing');
    renderAudioDiag();
    return true;
  }
  if (bgPlayPromise) return bgPlayPromise;
  setAudioDiag(reason);
  renderAudioDiag();
  try {
    const p = bg.play();
    if (p && typeof p.then === 'function') {
      bgPlayPromise = p.then(() => {
        setAudioDiag('bg-playing');
        renderAudioDiag();
        return true;
      }).catch((e) => {
        setAudioDiag('bg-play-fail', e);
        renderAudioDiag();
        return false;
      }).finally(() => {
        bgPlayPromise = null;
      });
      return bgPlayPromise;
    }
    setAudioDiag('bg-playing');
    renderAudioDiag();
    return true;
  } catch (e) {
    setAudioDiag('bg-play-throw', e);
    renderAudioDiag();
    return false;
  }
}

function stopBgMusic(reset = true) {
  bgmWanted = false;
  if (bgPlayPromise) bgPlayPromise = null;
  if (!bgAudioEl) {
    setAudioDiag('bg-stopped');
    renderAudioDiag();
    return;
  }
  try { bgAudioEl.pause(); } catch (_) {}
  if (reset) {
    try { bgAudioEl.currentTime = 0; } catch (_) {}
  }
  setAudioDiag(reset ? 'bg-stopped' : 'bg-paused');
  renderAudioDiag();
}

async function initAudio() {
  if (audioReady) return true;
  if (audioLoading) return audioLoading;
  setAudioDiag('init-audio');
  renderAudioDiag();
  audioLoading = (async () => {
    ensureAudioGraph();
    if (!audioCtx) { setAudioDiag('init-no-context'); renderAudioDiag(); return false; }
    if (audioCtx.state !== 'running') { setAudioDiag('init-context-not-running'); renderAudioDiag(); return false; }
    const entries = await Promise.all(Object.entries(SFX_FILES).map(async ([name, src]) => {
      try {
        const res = await fetch(src, { cache: 'force-cache' });
        if (!res.ok) return [name, null];
        const arrayBuffer = await res.arrayBuffer();
        const buffer = await decodeAudioCompat(audioCtx, arrayBuffer);
        return [name, buffer];
      } catch (_) {
        return [name, null];
      }
    }));
    entries.forEach(([name, buffer]) => { audioBuffers[name] = buffer; });
    audioReady = Object.values(audioBuffers).some(Boolean);
    setAudioDiag(audioReady ? 'sfx-ready' : 'sfx-missing');
    renderAudioDiag();
    return audioReady;
  })().finally(() => { audioLoading = null; renderAudioDiag(); });
  return audioLoading;
}

function canPlayNow(name) {
  const t = performance.now();
  const minGap = SFX_MIN_GAP_MS[name] || 0;
  if (t - (lastPlayAt[name] || 0) < minGap) return false;
  lastPlayAt[name] = t;
  return true;
}

function playSynth(name) {
  if (!audioCtx || !masterGain || audioCtx.state !== 'running') return;
  const t0 = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(masterGain);
  if (name === 'jump') {
    osc.type = 'square';
    osc.frequency.setValueAtTime(420, t0);
    osc.frequency.exponentialRampToValueAtTime(250, t0 + 0.11);
    gain.gain.setValueAtTime(0.0001, t0);
    gain.gain.exponentialRampToValueAtTime(0.18, t0 + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.12);
    osc.start(t0);
    osc.stop(t0 + 0.13);
  } else if (name === 'collect') {
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(620, t0);
    osc.frequency.exponentialRampToValueAtTime(980, t0 + 0.09);
    gain.gain.setValueAtTime(0.0001, t0);
    gain.gain.exponentialRampToValueAtTime(0.22, t0 + 0.008);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.11);
    osc.start(t0);
    osc.stop(t0 + 0.12);
  } else {
    osc.type = 'square';
    osc.frequency.setValueAtTime(740, t0);
    osc.frequency.setValueAtTime(980, t0 + 0.08);
    gain.gain.setValueAtTime(0.0001, t0);
    gain.gain.exponentialRampToValueAtTime(0.2, t0 + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.2);
    osc.start(t0);
    osc.stop(t0 + 0.22);
  }
}

function playSound(name) {
  if (!soundOn || !canPlayNow(name)) return;
  if (!audioCtx || !masterGain) {
    primeAudioFromGesture();
    return;
  }
  if (audioCtx.state !== 'running') {
    setAudioDiag('play-resume-' + name);
    renderAudioDiag();
    audioCtx.resume().then(() => {
      if (soundOn) playSound(name);
    }).catch(() => {});
    return;
  }
  const buffer = audioBuffers[name];
  if (!audioReady || !buffer) {
    playSynth(name);
    return;
  }
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  const gain = audioCtx.createGain();
  gain.gain.value = name === 'celebrate' ? 1 : 0.95;
  source.connect(gain);
  gain.connect(masterGain);
  source.start(0);
}
function sfxJump() { playSound('jump'); }
function sfxCollect() { playSound('collect'); }
function sfxCelebrate() { playSound('celebrate'); }

async function primeAudioFromGesture() {
  if (!soundOn) return false;
  if (audioPriming) return audioPriming;
  audioPriming = (async () => {
    audioDiagGestureCount++;
    setAudioDiag('gesture');
    renderAudioDiag();
    const ok = await ensureAudioUnlocked().catch(() => false);
    if (!ok) return false;

    // Some mobile browsers need one tiny non-zero sample to fully open the audio route.
    if (!outputRoutePrimed && audioCtx && masterGain && audioCtx.state === 'running') {
      try {
        const t0 = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(660, t0);
        gain.gain.setValueAtTime(0.0001, t0);
        gain.gain.exponentialRampToValueAtTime(0.03, t0 + 0.005);
        gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.05);
        osc.connect(gain);
        gain.connect(masterGain);
        osc.start(t0);
        osc.stop(t0 + 0.055);
        outputRoutePrimed = true;
        setAudioDiag('route-primed');
        renderAudioDiag();
      } catch (e) {
        setAudioDiag('route-prime-fail', e);
        renderAudioDiag();
      }
    }
    ensureSfxLoading();
    ensureBgAudio();
    if (typeof STATE !== 'undefined' && (state === STATE.PLAYING || bgmWanted)) {
      await startBgMusic('bg-play-gesture');
    }
    setAudioDiag('primed');
    renderAudioDiag();
    return true;
  })().finally(() => {
    audioPriming = null;
    renderAudioDiag();
  });
  return audioPriming;
}

async function playDebugBeep() {
  if (!soundOn) {
    soundOn = true;
    updateSoundButton();
  }
  await primeAudioFromGesture();
  sfxCollect();
  if (typeof STATE !== 'undefined' && state === STATE.PLAYING) {
    startBgMusic('bg-play-debug');
  }
  setAudioDiag('debug-beep');
  renderAudioDiag();
}

function updateSoundButton() {
  const btn = document.getElementById('sound-btn');
  if (!btn) return;
  btn.classList.toggle('is-off', !soundOn);
  const label = soundOn ? 'Sound on' : 'Sound off';
  btn.setAttribute('aria-label', label);
  btn.title = label;
}

function toggleSound() {
  soundOn = !soundOn;
  ensureBgAudio();
  if (soundOn) {
    primeAudioFromGesture();
    if (state === STATE.PLAYING) startBgMusic('bg-play-toggle');
  } else {
    stopBgMusic(false);
  }
  if (masterGain && audioCtx) {
    const target = soundOn ? 1 : 0;
    masterGain.gain.setTargetAtTime(target, audioCtx.currentTime, 0.01);
  }
  if (bgAudioEl) bgAudioEl.volume = soundOn ? BGM_VOLUME_ON : 0;
  updateSoundButton();
  renderAudioDiag();
}

document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    if (soundOn && state === STATE.PLAYING) {
      bgmWanted = true;
      primeAudioFromGesture();
      startBgMusic('bg-play-visible');
    }
    return;
  }
  if (bgAudioEl && !bgAudioEl.paused) bgAudioEl.pause();
  setAudioDiag('bg-hidden');
  renderAudioDiag();
});
updateSoundButton();
renderAudioDiag();

// ============ CANVAS SETUP ============
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W, H, scale;

function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
  scale = Math.min(W, H) / 400;
}
resize();
window.addEventListener('resize', () => { resize(); skyCacheH = 0; });

// ============ GAME STATE ============
const STATE = { START: 0, PLAYING: 1, ENDING: 2, END: 3, RESULT: 4 };
let state = STATE.START;
let heartsCollected = 0;
let totalHearts = 10;
let gameTimer = 0;
let ilaBackgroundUnlocked = false;
let startSecretStep = 0;
const GAME_DURATION = 5000;
// Scale scroll distance to screen width so it feels right on both phone and desktop
// Phone (~375px) -> ~750px, Desktop (~1400px) -> ~1200px
const SCROLL_DIST = Math.max(700, Math.min(1200, W * 1.8));
let lastTime = 0;

// ============ CHARACTER ============
const player = {
  x: 0, y: 0, vy: 0, groundY: 0,
  width: 28, height: 32,
  jumping: false, frame: 0, frameTimer: 0,
  eyeBlink: 0
};

// ============ HEARTS ============
let hearts = [];
let particles = [];

// ============ CLOUDS ============
let clouds = [];
function initClouds() {
  clouds = [];
  for (let i = 0; i < 6; i++) {
    clouds.push({
      x: Math.random() * W * 1.5,
      y: 30 + Math.random() * (H * 0.35),
      w: 40 + Math.random() * 60,
      speed: 15 + Math.random() * 20,
      opacity: 0.3 + Math.random() * 0.3
    });
  }
}

// ============ GROUND ============
let groundOffset = 0;

// ============ CONFETTI ============
let confetti = [];

// ============ INIT / START ============
function initGame() {
  heartsCollected = 0;
  gameTimer = 0;
  player.x = W * 0.15;
  player.groundY = H - 80 * scale;
  player.y = player.groundY;
  player.vy = 0;
  player.jumping = false;
  player.frame = 0;
  hearts = [];
  particles = [];
  confetti = [];
  groundOffset = 0;
  initClouds();
  spawnHearts();
  updateHUD();
}

function spawnHearts() {
  hearts = [];
  // Use a fixed scroll distance so mobile and desktop feel the same pace
  const totalScrollDist = SCROLL_DIST;
  const startOffset = totalScrollDist * 0.08;
  const endOffset = totalScrollDist * 0.92;
  const spacing = (endOffset - startOffset) / totalHearts;
  for (let i = 0; i < totalHearts; i++) {
    const baseX = player.x + startOffset + i * spacing;
    const tier = Math.random();
    let yPos;
    if (tier < 0.35) yPos = player.groundY - 20 * scale;
    else if (tier < 0.7) yPos = player.groundY - 70 * scale;
    else yPos = player.groundY - 120 * scale;
    hearts.push({
      x: baseX + (Math.random() - 0.5) * 40,
      y: yPos,
      size: 14 * scale,
      alive: true,
      bobOffset: Math.random() * Math.PI * 2,
      popTimer: 0
    });
  }
}

function updateHUD() {
  document.getElementById('heart-counter').textContent = `HEARTS: ${heartsCollected}`;
}

// ============ DRAWING HELPERS ============
function drawPixelRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(Math.round(x), Math.round(y), Math.round(w), Math.round(h));
}

// Pre-render heart to an offscreen canvas (drawn once, stamped many times)
const heartCache = {};
function getHeartCanvas(size, color) {
  const key = size + color;
  if (heartCache[key]) return heartCache[key];
  const s = size / 8;
  const w = Math.ceil(s * 9), h = Math.ceil(s * 6);
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const hctx = c.getContext('2d');
  hctx.fillStyle = color;
  const rows = [
    [-3,-1,-2,-1,1,-1,2,-1],
    [-4,0,-3,0,-2,0,-1,0,0,0,1,0,2,0,3,0],
    [-4,1,-3,1,-2,1,-1,1,0,1,1,1,2,1,3,1],
    [-3,2,-2,2,-1,2,0,2,1,2,2,2],
    [-2,3,-1,3,0,3,1,3],
    [-1,4,0,4]
  ];
  const ox = 4 * s, oy = s;
  rows.forEach(row => {
    for (let i = 0; i < row.length; i += 2)
      hctx.fillRect(Math.round(ox + row[i]*s), Math.round(oy + row[i+1]*s), Math.ceil(s), Math.ceil(s));
  });
  heartCache[key] = { canvas: c, ox: ox, oy: oy };
  return heartCache[key];
}

function drawHeart(cx, cy, size, color) {
  const h = getHeartCanvas(size, color);
  ctx.drawImage(h.canvas, Math.round(cx - h.ox), Math.round(cy - h.oy));
}

function drawCharacter(x, y) {
  const s = scale * 1.2;
  const px = Math.round(x);
  const py = Math.round(y);

  // Body (pink rounded)
  drawPixelRect(px - 10*s, py - 24*s, 20*s, 24*s, '#ff9bc5');
  // Body highlight
  drawPixelRect(px - 8*s, py - 22*s, 4*s, 8*s, '#ffb8d8');

  // Eyes
  const blinkOpen = player.eyeBlink < 0.9;
  if (blinkOpen) {
    drawPixelRect(px - 6*s, py - 18*s, 4*s, 5*s, '#fff');
    drawPixelRect(px + 2*s, py - 18*s, 4*s, 5*s, '#fff');
    drawPixelRect(px - 4*s, py - 17*s, 2*s, 3*s, '#222');
    drawPixelRect(px + 4*s, py - 17*s, 2*s, 3*s, '#222');
  } else {
    drawPixelRect(px - 6*s, py - 16*s, 5*s, 2*s, '#222');
    drawPixelRect(px + 2*s, py - 16*s, 5*s, 2*s, '#222');
  }

  // Cheeks
  drawPixelRect(px - 10*s, py - 12*s, 4*s, 3*s, '#ff7eb3');
  drawPixelRect(px + 6*s, py - 12*s, 4*s, 3*s, '#ff7eb3');

  // Mouth (smile)
  drawPixelRect(px - 2*s, py - 8*s, 5*s, 2*s, '#c0507a');

  // Feet
  const bounce = player.jumping ? 0 : Math.sin(player.frame * 0.3) * 3 * s;
  drawPixelRect(px - 8*s, py + bounce, 6*s, 4*s, '#ff7eb3');
  drawPixelRect(px + 2*s, py - bounce, 6*s, 4*s, '#ff7eb3');

  // Heart antenna
  drawPixelRect(px, py - 30*s, 2*s, 6*s, '#c0507a');
  drawHeart(px + 1*s, py - 36*s, 8*s, '#ff6b9d');
}

function drawGround() {
  const groundTop = H - 60 * scale;
  // Main ground
  ctx.fillStyle = '#8bac0f';
  ctx.fillRect(0, groundTop, W, H - groundTop);
  // Dark edge
  ctx.fillStyle = '#6d8b0a';
  ctx.fillRect(0, groundTop, W, 4 * scale);
  // Grass tufts
  ctx.fillStyle = '#9bbc0f';
  const tileW = 24 * scale;
  const off = groundOffset % tileW;
  for (let x = -tileW + off; x < W + tileW; x += tileW) {
    ctx.fillRect(Math.round(x), groundTop - 3*scale, 8*scale, 3*scale);
  }
}

// Cache the sky gradient as an offscreen canvas (recreated on resize)
let skyCache = null;
let skyCacheH = 0;
function getSkyCanvas() {
  if (skyCache && skyCacheH === H) return skyCache;
  skyCache = document.createElement('canvas');
  skyCache.width = 1; skyCache.height = H;
  const sctx = skyCache.getContext('2d');
  const grad = sctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#b8d4ff');
  grad.addColorStop(0.6, '#e2eeff');
  grad.addColorStop(1, '#ffdef2');
  sctx.fillStyle = grad;
  sctx.fillRect(0, 0, 1, H);
  skyCacheH = H;
  return skyCache;
}

function drawBackground(dt) {
  ctx.drawImage(getSkyCanvas(), 0, 0, 1, H, 0, 0, W, H);

  // Clouds
  clouds.forEach(c => {
    if (state === STATE.PLAYING) c.x -= c.speed * dt;
    if (c.x + c.w < -20) { c.x = W + 40; c.y = 30 + Math.random() * (H*0.35); }
    ctx.fillStyle = `rgba(255,255,255,${c.opacity})`;
    const cw = c.w * scale * 0.5;
    const ch = cw * 0.5;
    roundRect(c.x, c.y, cw, ch, ch * 0.4);
  });
}

function drawIlaBackgroundMessage() {
  if (!ilaBackgroundUnlocked || state !== STATE.PLAYING) return;
  const label = 'Ila <3';
  const fontSize = Math.max(16, Math.min(36, Math.round(Math.min(W, H) * 0.07)));
  const x = W * 0.5;
  const y = H * 0.36;
  const pulse = 0.85 + Math.sin(performance.now() * 0.0032) * 0.15;

  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = `${fontSize}px "Press Start 2P", monospace`;

  const textW = ctx.measureText(label).width;
  const boxW = textW + fontSize * 0.9;
  const boxH = fontSize * 1.75;
  ctx.globalAlpha = 0.42 * pulse;
  ctx.fillStyle = '#ff6b9d';
  roundRect(x - boxW / 2, y - boxH / 2, boxW, boxH, Math.max(7, fontSize * 0.22));

  ctx.globalAlpha = 0.95;
  ctx.shadowColor = 'rgba(255,107,157,0.6)';
  ctx.shadowBlur = Math.max(4, Math.round(fontSize * 0.24));
  ctx.lineWidth = Math.max(2, Math.round(fontSize * 0.14));
  ctx.strokeStyle = 'rgba(140,40,80,0.95)';
  ctx.strokeText(label, x, y);
  ctx.fillStyle = '#fff7fd';
  ctx.fillText(label, x, y);
  ctx.restore();
}

function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.fill();
}

// ============ PARTICLES ============
function spawnParticles(x, y) {
  for (let i = 0; i < 8; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 200,
      vy: (Math.random() - 0.5) * 200 - 80,
      life: 0.6,
      maxLife: 0.6,
      size: (3 + Math.random() * 4) * scale,
      color: Math.random() > 0.5 ? '#ff6b9d' : '#ffb3d0'
    });
  }
}

function spawnConfetti() {
  for (let i = 0; i < 80; i++) {
    confetti.push({
      x: W * 0.5 + (Math.random() - 0.5) * W * 0.3,
      y: -20 - Math.random() * H * 0.5,
      vx: (Math.random() - 0.5) * 100,
      vy: 80 + Math.random() * 200,
      size: (4 + Math.random() * 8) * scale,
      color: ['#ff6b9d','#ffb3d0','#ff9bc5','#c0507a','#fff','#ffd700'][Math.floor(Math.random()*6)],
      rot: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 8
    });
  }
}

// ============ UPDATE ============
function update(dt) {
  if (state === STATE.PLAYING) {
    gameTimer += dt * 1000;

    // Move world
    const speed = (SCROLL_DIST / (GAME_DURATION / 1000)) * dt;
    groundOffset -= speed;

    // Move hearts toward player
    hearts.forEach(h => { if (h.alive) h.x -= speed; });

    // Player physics
    if (player.jumping) {
      player.vy += 1800 * scale * dt;
      player.y += player.vy * dt;
      if (player.y >= player.groundY) {
        player.y = player.groundY;
        player.vy = 0;
        player.jumping = false;
      }
    }

    // Player animation
    player.frameTimer += dt;
    if (player.frameTimer > 0.08) { player.frame++; player.frameTimer = 0; }
    player.eyeBlink = (Math.sin(performance.now() * 0.003) + 1) * 0.5;
    if (player.eyeBlink > 0.95) player.eyeBlink = 1;
    else player.eyeBlink = 0;

    // Heart collision
    hearts.forEach(h => {
      if (!h.alive) return;
      const bobY = h.y + Math.sin(performance.now() * 0.004 + h.bobOffset) * 6 * scale;
      const dx = player.x - h.x;
      const dy = (player.y - 12*scale) - bobY;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < 30 * scale) {
        h.alive = false;
        heartsCollected++;
        updateHUD();
        sfxCollect();
        spawnParticles(h.x, bobY);
      }
    });

    // Timer check
    if (gameTimer >= GAME_DURATION) {
      state = STATE.ENDING;
      setTimeout(showEndScreen, 600);
    }
  }

  // Update particles
  particles = particles.filter(p => {
    p.life -= dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 300 * dt;
    return p.life > 0;
  });

  // Update confetti
  confetti.forEach(c => {
    c.x += c.vx * dt;
    c.y += c.vy * dt;
    c.rot += c.rotSpeed * dt;
  });
  confetti = confetti.filter(c => c.y < H + 50);
}

// ============ RENDER ============
function render() {
  const playing = state === STATE.PLAYING || state === STATE.ENDING;

  drawBackground(1/60);
  drawIlaBackgroundMessage();
  drawGround();

  if (playing) {
    // Draw hearts
    hearts.forEach(h => {
      if (!h.alive) return;
      const bobY = h.y + Math.sin(performance.now() * 0.004 + h.bobOffset) * 6 * scale;
      drawHeart(h.x, bobY, h.size, '#ff6b9d');
    });

    // Draw character
    drawCharacter(player.x, player.y);
  }

  // Particles
  if (particles.length > 0) {
    particles.forEach(p => {
      ctx.globalAlpha = p.life / p.maxLife;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x | 0, p.y | 0, p.size, p.size);
    });
    ctx.globalAlpha = 1;
  }

  // Confetti ‚Äî batch by color to reduce state changes
  if (confetti.length > 0) {
    confetti.forEach(c => {
      ctx.fillStyle = c.color;
      ctx.fillRect((c.x - c.size/2) | 0, (c.y - c.size/4) | 0, c.size, c.size/2);
    });
  }
}

// ============ GAME LOOP ============
function loop(time) {
  const dt = Math.min((time - lastTime) / 1000, 0.05);
  lastTime = time;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

// ============ INPUT ============
function handleTap(e) {
  e.preventDefault();
  primeAudioFromGesture();
  if (state === STATE.PLAYING && !player.jumping) {
    player.jumping = true;
    player.vy = -550 * scale;
    sfxJump();
  }
}

if (window.PointerEvent) {
  canvas.addEventListener('pointerdown', handleTap);
} else {
  canvas.addEventListener('touchstart', handleTap, { passive: false });
}

// ============ SCREENS ============
function bindPress(el, handler) {
  if (!el) return;
  if (window.PointerEvent) {
    el.addEventListener('pointerdown', handler);
  } else {
    el.addEventListener('touchstart', handler, { passive: true });
    el.addEventListener('mousedown', handler);
  }
}

function resetStartSecret() {
  startSecretStep = 0;
}

function advanceStartSecret(expectedStep) {
  if (state !== STATE.START) return;
  if (startSecretStep === expectedStep) {
    startSecretStep++;
  } else {
    resetStartSecret();
  }
}

const startScreen = document.getElementById('start-screen');
const startTitle = startScreen.querySelector('h1');
const startHint = startScreen.querySelector('p');

bindPress(startTitle, (e) => {
  if (e) e.preventDefault();
  advanceStartSecret(0);
});

bindPress(startHint, (e) => {
  if (e) e.preventDefault();
  advanceStartSecret(1);
});

function showEndScreen() {
  state = STATE.END;
  stopBgMusic();
  document.getElementById('hud').classList.add('hidden');
  const endScreen = document.getElementById('end-screen');
  endScreen.classList.remove('hidden');
  document.getElementById('start-screen').classList.add('hidden');
  endScreen.querySelector('.hearts-result').textContent = `You collected ${heartsCollected} hearts!`;
}

document.getElementById('start-btn').addEventListener('click', (e) => {
  e.preventDefault();
  ilaBackgroundUnlocked = startSecretStep === 2;
  resetStartSecret();
  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
  state = STATE.PLAYING;
  initGame();
  bgmWanted = true;
  primeAudioFromGesture();
  startBgMusic('bg-play-start');
});

document.getElementById('yes-btn').addEventListener('click', () => {
  primeAudioFromGesture();
  sfxCelebrate();
  spawnConfetti();
  setTimeout(spawnConfetti, 400);
  document.getElementById('end-screen').classList.add('hidden');
  const result = document.getElementById('result-screen');
  result.classList.remove('hidden');
  result.innerHTML = `
    <h2 style="color:#ff6b9d;text-shadow:2px 2px 0 #c0507a">YAY!</h2>
    <p style="color:#c0507a;font-size:clamp(10px,3vw,16px);margin-top:10px;text-shadow:1px 1px 0 rgba(255,255,255,0.5)">Happy Valentine's Day! üíñ</p>
    <button class="play-again-btn" onclick="location.reload()">PLAY AGAIN</button>
  `;
  state = STATE.RESULT;
  localStorage.setItem('valentine_yes', 'true');
});

// NO button - always dodges, can never be clicked
const noBtn = document.getElementById('no-btn');
const yesBtn = document.getElementById('yes-btn');
let noAttempts = 0;

function dodgeNo(e) {
  if (e) { e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation(); }
  noAttempts++;

  // Make YES button grow with each attempt
  const growScale = 1 + noAttempts * 0.08;
  yesBtn.style.transform = `scale(${growScale})`;
  yesBtn.style.animation = 'none';
  void yesBtn.offsetHeight; // reflow
  yesBtn.style.animation = 'yesPulse 0.6s ease-in-out infinite';

  // Teleport to a random spot, keeping it on screen
  const pad = 30;
  const nx = pad + Math.random() * (W - pad * 2 - 60);
  const ny = pad + Math.random() * (H - pad * 2 - 30);
  noBtn.style.position = 'fixed';
  noBtn.style.left = nx + 'px';
  noBtn.style.top = ny + 'px';
  noBtn.style.zIndex = '100';
  // Shrink it further each time (min 0.3)
  const shrink = Math.max(0.3, 1 - noAttempts * 0.08);
  noBtn.style.transform = `scale(${shrink})`;
}

// Block click entirely ‚Äî dodge happens on pointer/touch events only
noBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); });
// Desktop hover
noBtn.addEventListener('pointerenter', dodgeNo);
// Mobile tap ‚Äî touchstart fires before click so we dodge first
noBtn.addEventListener('touchstart', dodgeNo, { passive: false });
// Fallback for non-touch pointer devices
noBtn.addEventListener('pointerdown', dodgeNo);

// ============ BOOT ============
initClouds();
lastTime = performance.now();
requestAnimationFrame(loop);
</script>
</body>
</html>
