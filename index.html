<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Valentine's Game</title>
<script>window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };</script>
<script defer src="/_vercel/insights/script.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
  overflow: hidden;
  touch-action: none;
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
  font-family: 'Press Start 2P', monospace;
  background: #1a1a2e;
  position: fixed;
  width: 100%;
  height: 100%;
}

canvas {
  display: block;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

#ui-layer {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  z-index: 10;
}

#ui-layer > * { pointer-events: auto; }

.hidden { display: none !important; }

/* START SCREEN */
#start-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 20px;
  text-align: center;
  padding: 20px;
}

#start-screen h1 {
  font-size: clamp(18px, 5vw, 36px);
  color: #ff6b9d;
  text-shadow: 3px 3px 0 #c0507a, -1px -1px 0 #ffb3d0;
  line-height: 1.4;
}

#start-screen p {
  font-size: clamp(8px, 2.5vw, 14px);
  color: #c0507a;
  line-height: 1.6;
  text-shadow: 1px 1px 0 rgba(255,255,255,0.6);
}

.pixel-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(12px, 3vw, 20px);
  padding: 16px 32px;
  border: none;
  cursor: pointer;
  position: relative;
  color: #fff;
  background: #ff6b9d;
  box-shadow:
    0 4px 0 #c0507a,
    0 6px 0 #a0406a,
    inset 0 -2px 0 rgba(0,0,0,0.1);
  transition: transform 0.1s, box-shadow 0.1s;
  image-rendering: pixelated;
}

.pixel-btn:active {
  transform: translateY(4px);
  box-shadow:
    0 0 0 #c0507a,
    0 2px 0 #a0406a;
}

/* HUD */
#hud {
  position: fixed;
  top: 12px;
  left: 0; right: 0;
  display: flex;
  justify-content: center;
  z-index: 20;
  pointer-events: none;
}

#heart-counter {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(10px, 2.5vw, 16px);
  color: #fff;
  background: rgba(0,0,0,0.5);
  padding: 8px 16px;
  border: 2px solid #ff6b9d;
}

/* END SCREEN */
#end-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 24px;
  text-align: center;
  padding: 20px;
  width: 100%;
}

#end-screen h2 {
  font-size: clamp(14px, 4vw, 28px);
  color: #ff6b9d;
  text-shadow: 2px 2px 0 #c0507a;
  line-height: 1.5;
}

#end-screen .hearts-result {
  font-size: clamp(10px, 2.5vw, 16px);
  color: #ff6b9d;
  text-shadow: 1px 1px 0 #c0507a;
  margin-bottom: 8px;
}

#yes-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(20px, 5vw, 36px);
  padding: 24px 48px;
  width: min(80vw, 400px);
  border: none;
  cursor: pointer;
  color: #fff;
  background: #ff6b9d;
  box-shadow:
    0 6px 0 #c0507a,
    0 10px 0 #a0406a,
    0 0 30px rgba(255,107,157,0.4);
  animation: yesPulse 1s ease-in-out infinite;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
}

#yes-btn:active {
  transform: translateY(6px);
  box-shadow: 0 0 0 #c0507a, 0 4px 0 #a0406a;
}

@keyframes yesPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

#no-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: 6px;
  padding: 4px 8px;
  border: 1px solid #999;
  background: #888;
  color: #bbb;
  cursor: pointer;
  opacity: 0.5;
  margin-top: 20px;
  transition: transform 0.15s, left 0.15s, top 0.15s;
  /* Ensure minimum touch target for mobile accessibility */
  min-width: 44px;
  min-height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* RESULT SCREEN */
#result-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 20px;
  text-align: center;
  padding: 20px;
}

#result-screen h2 {
  font-size: clamp(24px, 6vw, 48px);
  line-height: 1.4;
}

#result-screen p {
  font-size: clamp(8px, 2.5vw, 14px);
  color: #ffb3d0;
  line-height: 1.6;
}

.play-again-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(8px, 2vw, 12px);
  padding: 12px 24px;
  border: none;
  cursor: pointer;
  color: #fff;
  background: #ff6b9d;
  box-shadow: 0 3px 0 #c0507a;
  margin-top: 10px;
}

.play-again-btn:active {
  transform: translateY(3px);
  box-shadow: none;
}
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="hud" class="hidden">
  <div id="heart-counter">HEARTS: 0</div>
</div>

<div id="ui-layer">
  <div id="start-screen">
    <h1>VALENTINE'S<br>GAME</h1>
    <p>Tap to jump and<br>collect hearts! ‚ù§Ô∏è</p>
    <button class="pixel-btn" id="start-btn">TAP TO START</button>
  </div>

  <div id="end-screen" class="hidden">
    <p class="hearts-result"></p>
    <h2>WILL YOU BE<br>MY VALENTINE?</h2>
    <button id="yes-btn">YES! üíñ</button>
    <button id="no-btn">no</button>
  </div>

  <div id="result-screen" class="hidden"></div>
</div>

<script>
// ============ AUDIO (Web Audio API) ============
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function ensureAudio() {
  if (!audioCtx) audioCtx = new AudioCtx();
}

function playTone(freq, duration, type = 'square', vol = 0.15) {
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = vol;
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + duration);
}

function sfxJump() { playTone(500, 0.12); setTimeout(() => playTone(700, 0.08), 40); }
function sfxCollect() { playTone(880, 0.08); setTimeout(() => playTone(1100, 0.08), 60); setTimeout(() => playTone(1320, 0.12), 120); }
function sfxCelebrate() {
  [0,100,200,300,400].forEach((d,i) => setTimeout(() => playTone(600 + i*150, 0.15), d));
}

// ============ BACKGROUND MUSIC ============
let bgMusicInterval = null;
let bgMusicPlaying = false;

// Simple cute chiptune melody ‚Äî loops a short phrase
const melodyNotes = [
  // freq, duration(ms), rest(ms)
  [523, 180, 20],  // C5
  [587, 180, 20],  // D5
  [659, 360, 40],  // E5
  [587, 180, 20],  // D5
  [523, 180, 20],  // C5
  [440, 360, 40],  // A4
  [494, 180, 20],  // B4
  [523, 180, 20],  // C5
  [587, 360, 40],  // D5
  [523, 180, 20],  // C5
  [494, 180, 20],  // B4
  [440, 360, 200], // A4 (longer rest before loop)
  [523, 180, 20],  // C5
  [659, 180, 20],  // E5
  [698, 360, 40],  // F5
  [659, 180, 20],  // E5
  [587, 180, 20],  // D5
  [523, 360, 40],  // C5
  [440, 180, 20],  // A4
  [494, 180, 20],  // B4
  [523, 540, 300],  // C5 (held, longer rest)
];

function startBgMusic() {
  if (bgMusicPlaying) return;
  ensureAudio();
  bgMusicPlaying = true;
  let noteIdx = 0;

  function playNext() {
    if (!bgMusicPlaying) return;
    const [freq, dur, rest] = melodyNotes[noteIdx % melodyNotes.length];
    playTone(freq, dur / 1000, 'triangle', 0.06);
    noteIdx++;
    bgMusicInterval = setTimeout(playNext, dur + rest);
  }
  playNext();
}

function stopBgMusic() {
  bgMusicPlaying = false;
  if (bgMusicInterval) { clearTimeout(bgMusicInterval); bgMusicInterval = null; }
}

// ============ CANVAS SETUP ============
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W, H, scale;

function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
  scale = Math.min(W, H) / 400;
}
resize();
window.addEventListener('resize', resize);

// ============ GAME STATE ============
const STATE = { START: 0, PLAYING: 1, ENDING: 2, END: 3, RESULT: 4 };
let state = STATE.START;
let heartsCollected = 0;
let totalHearts = 10;
let gameTimer = 0;
const GAME_DURATION = 5000;
let lastTime = 0;

// ============ CHARACTER ============
const player = {
  x: 0, y: 0, vy: 0, groundY: 0,
  width: 28, height: 32,
  jumping: false, frame: 0, frameTimer: 0,
  eyeBlink: 0
};

// ============ HEARTS ============
let hearts = [];
let particles = [];

// ============ CLOUDS ============
let clouds = [];
function initClouds() {
  clouds = [];
  for (let i = 0; i < 6; i++) {
    clouds.push({
      x: Math.random() * W * 1.5,
      y: 30 + Math.random() * (H * 0.35),
      w: 40 + Math.random() * 60,
      speed: 15 + Math.random() * 20,
      opacity: 0.3 + Math.random() * 0.3
    });
  }
}

// ============ GROUND ============
let groundOffset = 0;

// ============ CONFETTI ============
let confetti = [];

// ============ INIT / START ============
function initGame() {
  heartsCollected = 0;
  gameTimer = 0;
  player.x = W * 0.15;
  player.groundY = H - 80 * scale;
  player.y = player.groundY;
  player.vy = 0;
  player.jumping = false;
  player.frame = 0;
  hearts = [];
  particles = [];
  confetti = [];
  groundOffset = 0;
  initClouds();
  spawnHearts();
  updateHUD();
}

function spawnHearts() {
  hearts = [];
  const spacing = (W * 0.8) / totalHearts;
  for (let i = 0; i < totalHearts; i++) {
    const baseX = player.x + 120 + i * spacing;
    const tier = Math.random();
    let yPos;
    if (tier < 0.35) yPos = player.groundY - 20 * scale;
    else if (tier < 0.7) yPos = player.groundY - 70 * scale;
    else yPos = player.groundY - 120 * scale;
    hearts.push({
      x: baseX + (Math.random() - 0.5) * 40,
      y: yPos,
      size: 14 * scale,
      alive: true,
      bobOffset: Math.random() * Math.PI * 2,
      popTimer: 0
    });
  }
}

function updateHUD() {
  document.getElementById('heart-counter').textContent = `HEARTS: ${heartsCollected}`;
}

// ============ DRAWING HELPERS ============
function drawPixelRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(Math.round(x), Math.round(y), Math.round(w), Math.round(h));
}

function drawHeart(cx, cy, size, color) {
  ctx.fillStyle = color;
  const s = size / 8;
  // pixel heart shape
  const rows = [
    [-3,-1, -2,-1, 1,-1, 2,-1],
    [-4,0, -3,0, -2,0, -1,0, 0,0, 1,0, 2,0, 3,0],
    [-4,1, -3,1, -2,1, -1,1, 0,1, 1,1, 2,1, 3,1],
    [-3,2, -2,2, -1,2, 0,2, 1,2, 2,2],
    [-2,3, -1,3, 0,3, 1,3],
    [-1,4, 0,4]
  ];
  rows.forEach(row => {
    for (let i = 0; i < row.length; i += 2) {
      ctx.fillRect(Math.round(cx + row[i] * s), Math.round(cy + row[i+1] * s), Math.ceil(s), Math.ceil(s));
    }
  });
}

function drawCharacter(x, y) {
  const s = scale * 1.2;
  const px = Math.round(x);
  const py = Math.round(y);

  // Body (pink rounded)
  drawPixelRect(px - 10*s, py - 24*s, 20*s, 24*s, '#ff9bc5');
  // Body highlight
  drawPixelRect(px - 8*s, py - 22*s, 4*s, 8*s, '#ffb8d8');

  // Eyes
  const blinkOpen = player.eyeBlink < 0.9;
  if (blinkOpen) {
    drawPixelRect(px - 6*s, py - 18*s, 4*s, 5*s, '#fff');
    drawPixelRect(px + 2*s, py - 18*s, 4*s, 5*s, '#fff');
    drawPixelRect(px - 4*s, py - 17*s, 2*s, 3*s, '#222');
    drawPixelRect(px + 4*s, py - 17*s, 2*s, 3*s, '#222');
  } else {
    drawPixelRect(px - 6*s, py - 16*s, 5*s, 2*s, '#222');
    drawPixelRect(px + 2*s, py - 16*s, 5*s, 2*s, '#222');
  }

  // Cheeks
  drawPixelRect(px - 10*s, py - 12*s, 4*s, 3*s, '#ff7eb3');
  drawPixelRect(px + 6*s, py - 12*s, 4*s, 3*s, '#ff7eb3');

  // Mouth (smile)
  drawPixelRect(px - 2*s, py - 8*s, 5*s, 2*s, '#c0507a');

  // Feet
  const bounce = player.jumping ? 0 : Math.sin(player.frame * 0.3) * 3 * s;
  drawPixelRect(px - 8*s, py + bounce, 6*s, 4*s, '#ff7eb3');
  drawPixelRect(px + 2*s, py - bounce, 6*s, 4*s, '#ff7eb3');

  // Heart antenna
  drawPixelRect(px, py - 30*s, 2*s, 6*s, '#c0507a');
  drawHeart(px + 1*s, py - 36*s, 8*s, '#ff6b9d');
}

function drawGround() {
  const groundTop = H - 60 * scale;
  // Main ground
  ctx.fillStyle = '#8bac0f';
  ctx.fillRect(0, groundTop, W, H - groundTop);
  // Dark edge
  ctx.fillStyle = '#6d8b0a';
  ctx.fillRect(0, groundTop, W, 4 * scale);
  // Grass tufts
  ctx.fillStyle = '#9bbc0f';
  const tileW = 24 * scale;
  const off = groundOffset % tileW;
  for (let x = -tileW + off; x < W + tileW; x += tileW) {
    ctx.fillRect(Math.round(x), groundTop - 3*scale, 8*scale, 3*scale);
  }
}

function drawBackground(dt) {
  // Sky gradient
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#b8d4ff');
  grad.addColorStop(0.6, '#e2eeff');
  grad.addColorStop(1, '#ffdef2');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Clouds
  clouds.forEach(c => {
    if (state === STATE.PLAYING) c.x -= c.speed * dt;
    if (c.x + c.w < -20) { c.x = W + 40; c.y = 30 + Math.random() * (H*0.35); }
    ctx.fillStyle = `rgba(255,255,255,${c.opacity})`;
    const cw = c.w * scale * 0.5;
    const ch = cw * 0.5;
    roundRect(c.x, c.y, cw, ch, ch * 0.4);
  });
}

function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.fill();
}

// ============ PARTICLES ============
function spawnParticles(x, y) {
  for (let i = 0; i < 8; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 200,
      vy: (Math.random() - 0.5) * 200 - 80,
      life: 0.6,
      maxLife: 0.6,
      size: (3 + Math.random() * 4) * scale,
      color: Math.random() > 0.5 ? '#ff6b9d' : '#ffb3d0'
    });
  }
}

function spawnConfetti() {
  for (let i = 0; i < 80; i++) {
    confetti.push({
      x: W * 0.5 + (Math.random() - 0.5) * W * 0.3,
      y: -20 - Math.random() * H * 0.5,
      vx: (Math.random() - 0.5) * 100,
      vy: 80 + Math.random() * 200,
      size: (4 + Math.random() * 8) * scale,
      color: ['#ff6b9d','#ffb3d0','#ff9bc5','#c0507a','#fff','#ffd700'][Math.floor(Math.random()*6)],
      rot: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 8
    });
  }
}

// ============ UPDATE ============
function update(dt) {
  if (state === STATE.PLAYING) {
    gameTimer += dt * 1000;

    // Move world
    const speed = (W * 0.8 / (GAME_DURATION / 1000)) * dt;
    groundOffset -= speed;

    // Move hearts toward player
    hearts.forEach(h => { if (h.alive) h.x -= speed; });

    // Player physics
    if (player.jumping) {
      player.vy += 1800 * scale * dt;
      player.y += player.vy * dt;
      if (player.y >= player.groundY) {
        player.y = player.groundY;
        player.vy = 0;
        player.jumping = false;
      }
    }

    // Player animation
    player.frameTimer += dt;
    if (player.frameTimer > 0.08) { player.frame++; player.frameTimer = 0; }
    player.eyeBlink = (Math.sin(performance.now() * 0.003) + 1) * 0.5;
    if (player.eyeBlink > 0.95) player.eyeBlink = 1;
    else player.eyeBlink = 0;

    // Heart collision
    hearts.forEach(h => {
      if (!h.alive) return;
      const bobY = h.y + Math.sin(performance.now() * 0.004 + h.bobOffset) * 6 * scale;
      const dx = player.x - h.x;
      const dy = (player.y - 12*scale) - bobY;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < 30 * scale) {
        h.alive = false;
        heartsCollected++;
        updateHUD();
        sfxCollect();
        spawnParticles(h.x, bobY);
      }
    });

    // Timer check
    if (gameTimer >= GAME_DURATION) {
      state = STATE.ENDING;
      setTimeout(showEndScreen, 600);
    }
  }

  // Update particles
  particles = particles.filter(p => {
    p.life -= dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 300 * dt;
    return p.life > 0;
  });

  // Update confetti
  confetti.forEach(c => {
    c.x += c.vx * dt;
    c.y += c.vy * dt;
    c.rot += c.rotSpeed * dt;
  });
  confetti = confetti.filter(c => c.y < H + 50);
}

// ============ RENDER ============
function render() {
  ctx.clearRect(0, 0, W, H);
  drawBackground(1/60);
  drawGround();

  if (state === STATE.PLAYING || state === STATE.ENDING) {
    // Draw hearts
    hearts.forEach(h => {
      if (!h.alive) return;
      const bobY = h.y + Math.sin(performance.now() * 0.004 + h.bobOffset) * 6 * scale;
      drawHeart(h.x, bobY, h.size, '#ff6b9d');
      // Shine
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.fillRect(Math.round(h.x - h.size*0.15), Math.round(bobY - h.size*0.3), h.size*0.2, h.size*0.15);
    });

    // Draw character
    drawCharacter(player.x, player.y);
  }

  // Particles
  particles.forEach(p => {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.fillRect(Math.round(p.x), Math.round(p.y), p.size, p.size);
  });
  ctx.globalAlpha = 1;

  // Confetti
  confetti.forEach(c => {
    ctx.save();
    ctx.translate(c.x, c.y);
    ctx.rotate(c.rot);
    ctx.fillStyle = c.color;
    ctx.fillRect(-c.size/2, -c.size/4, c.size, c.size/2);
    ctx.restore();
  });
}

// ============ GAME LOOP ============
function loop(time) {
  const dt = Math.min((time - lastTime) / 1000, 0.05);
  lastTime = time;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

// ============ INPUT ============
function handleTap(e) {
  e.preventDefault();
  if (state === STATE.PLAYING && !player.jumping) {
    player.jumping = true;
    player.vy = -550 * scale;
    sfxJump();
  }
}

canvas.addEventListener('pointerdown', handleTap);

// ============ SCREENS ============
function showEndScreen() {
  state = STATE.END;
  stopBgMusic();
  document.getElementById('hud').classList.add('hidden');
  const endScreen = document.getElementById('end-screen');
  endScreen.classList.remove('hidden');
  document.getElementById('start-screen').classList.add('hidden');
  endScreen.querySelector('.hearts-result').textContent = `You collected ${heartsCollected} hearts!`;
}

document.getElementById('start-btn').addEventListener('click', () => {
  ensureAudio();
  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
  state = STATE.PLAYING;
  initGame();
  startBgMusic();
});

document.getElementById('yes-btn').addEventListener('click', () => {
  sfxCelebrate();
  spawnConfetti();
  setTimeout(spawnConfetti, 400);
  document.getElementById('end-screen').classList.add('hidden');
  const result = document.getElementById('result-screen');
  result.classList.remove('hidden');
  result.innerHTML = `
    <h2 style="color:#ff6b9d;text-shadow:2px 2px 0 #c0507a">YAY!</h2>
    <p style="color:#c0507a;font-size:clamp(10px,3vw,16px);margin-top:10px;text-shadow:1px 1px 0 rgba(255,255,255,0.5)">Happy Valentine's Day! üíñ</p>
    <button class="play-again-btn" onclick="location.reload()">PLAY AGAIN</button>
  `;
  state = STATE.RESULT;
  localStorage.setItem('valentine_yes', 'true');
});

// NO button - always dodges, can never be clicked
const noBtn = document.getElementById('no-btn');
const yesBtn = document.getElementById('yes-btn');
let noAttempts = 0;

function dodgeNo(e) {
  if (e) { e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation(); }
  noAttempts++;

  // Make YES button grow with each attempt
  const growScale = 1 + noAttempts * 0.08;
  yesBtn.style.transform = `scale(${growScale})`;
  yesBtn.style.animation = 'none';
  void yesBtn.offsetHeight; // reflow
  yesBtn.style.animation = 'yesPulse 0.6s ease-in-out infinite';

  // Teleport to a random spot, keeping it on screen
  const pad = 30;
  const nx = pad + Math.random() * (W - pad * 2 - 60);
  const ny = pad + Math.random() * (H - pad * 2 - 30);
  noBtn.style.position = 'fixed';
  noBtn.style.left = nx + 'px';
  noBtn.style.top = ny + 'px';
  noBtn.style.zIndex = '100';
  // Shrink it further each time (min 0.3)
  const shrink = Math.max(0.3, 1 - noAttempts * 0.08);
  noBtn.style.transform = `scale(${shrink})`;
}

// Block click entirely ‚Äî dodge happens on pointer/touch events only
noBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); });
// Desktop hover
noBtn.addEventListener('pointerenter', dodgeNo);
// Mobile tap ‚Äî touchstart fires before click so we dodge first
noBtn.addEventListener('touchstart', dodgeNo, { passive: false });
// Fallback for non-touch pointer devices
noBtn.addEventListener('pointerdown', dodgeNo);

// ============ BOOT ============
initClouds();
lastTime = performance.now();
requestAnimationFrame(loop);
</script>
</body>
</html>
