<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Valentine's Game</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><rect x='3' y='1' width='2' height='2' fill='%23ff6b9d'/><rect x='5' y='1' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='1' width='2' height='2' fill='%23ff6b9d'/><rect x='11' y='1' width='2' height='2' fill='%23ff6b9d'/><rect x='1' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='3' y='3' width='2' height='2' fill='%23ffb3d0'/><rect x='5' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='11' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='13' y='3' width='2' height='2' fill='%23ff6b9d'/><rect x='1' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='3' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='5' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='11' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='13' y='5' width='2' height='2' fill='%23ff6b9d'/><rect x='1' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='3' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='5' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='11' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='13' y='7' width='2' height='2' fill='%23ff6b9d'/><rect x='3' y='9' width='2' height='2' fill='%23ff6b9d'/><rect x='5' y='9' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='9' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='9' width='2' height='2' fill='%23ff6b9d'/><rect x='11' y='9' width='2' height='2' fill='%23ff6b9d'/><rect x='5' y='11' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='11' width='2' height='2' fill='%23ff6b9d'/><rect x='9' y='11' width='2' height='2' fill='%23ff6b9d'/><rect x='7' y='13' width='2' height='2' fill='%23ff6b9d'/></svg>">
<script>window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };</script>
<script defer src="/_vercel/insights/script.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
  overflow: hidden;
  touch-action: none;
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
  font-family: 'Press Start 2P', monospace;
  background: #1a1a2e;
  position: fixed;
  width: 100%;
  height: 100%;
}

canvas {
  display: block;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

#ui-layer {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  z-index: 10;
}

#ui-layer > * { pointer-events: auto; }

.hidden { display: none !important; }

/* START SCREEN */
#start-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 20px;
  text-align: center;
  padding: 20px;
}

#start-screen h1 {
  font-size: clamp(18px, 5vw, 36px);
  color: #ff6b9d;
  text-shadow: 3px 3px 0 #c0507a, -1px -1px 0 #ffb3d0;
  line-height: 1.4;
}

#start-screen p {
  font-size: clamp(8px, 2.5vw, 14px);
  color: #c0507a;
  line-height: 1.6;
  text-shadow: 1px 1px 0 rgba(255,255,255,0.6);
}

.pixel-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(12px, 3vw, 20px);
  padding: 16px 32px;
  border: none;
  cursor: pointer;
  position: relative;
  color: #fff;
  background: #ff6b9d;
  box-shadow:
    0 4px 0 #c0507a,
    0 6px 0 #a0406a,
    inset 0 -2px 0 rgba(0,0,0,0.1);
  transition: transform 0.1s, box-shadow 0.1s;
  image-rendering: pixelated;
}

.pixel-btn:active {
  transform: translateY(4px);
  box-shadow:
    0 0 0 #c0507a,
    0 2px 0 #a0406a;
}

/* HUD */
#hud {
  position: fixed;
  top: 12px;
  left: 0; right: 0;
  display: flex;
  justify-content: center;
  z-index: 20;
  pointer-events: none;
}

#heart-counter {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(10px, 2.5vw, 16px);
  color: #fff;
  background: rgba(0,0,0,0.5);
  padding: 8px 16px;
  border: 2px solid #ff6b9d;
}

/* END SCREEN */
#end-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 24px;
  text-align: center;
  padding: 20px;
  width: 100%;
}

#end-screen h2 {
  font-size: clamp(14px, 4vw, 28px);
  color: #ff6b9d;
  text-shadow: 2px 2px 0 #c0507a;
  line-height: 1.5;
}

#end-screen .hearts-result {
  font-size: clamp(10px, 2.5vw, 16px);
  color: #ff6b9d;
  text-shadow: 1px 1px 0 #c0507a;
  margin-bottom: 8px;
}

#yes-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(20px, 5vw, 36px);
  padding: 24px 48px;
  width: min(80vw, 400px);
  border: none;
  cursor: pointer;
  color: #fff;
  background: #ff6b9d;
  box-shadow:
    0 6px 0 #c0507a,
    0 10px 0 #a0406a,
    0 0 30px rgba(255,107,157,0.4);
  animation: yesPulse 1s ease-in-out infinite;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
}

#yes-btn:active {
  transform: translateY(6px);
  box-shadow: 0 0 0 #c0507a, 0 4px 0 #a0406a;
}

@keyframes yesPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

#no-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: 6px;
  padding: 4px 8px;
  border: 1px solid #999;
  background: #888;
  color: #bbb;
  cursor: pointer;
  opacity: 0.5;
  margin-top: 20px;
  transition: transform 0.15s, left 0.15s, top 0.15s;
  /* Ensure minimum touch target for mobile accessibility */
  min-width: 44px;
  min-height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* RESULT SCREEN */
#result-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 20px;
  text-align: center;
  padding: 20px;
}

#result-screen h2 {
  font-size: clamp(24px, 6vw, 48px);
  line-height: 1.4;
}

#result-screen p {
  font-size: clamp(8px, 2.5vw, 14px);
  color: #ffb3d0;
  line-height: 1.6;
}

.play-again-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(8px, 2vw, 12px);
  padding: 12px 24px;
  border: none;
  cursor: pointer;
  color: #fff;
  background: #ff6b9d;
  box-shadow: 0 3px 0 #c0507a;
  margin-top: 10px;
}

.play-again-btn:active {
  transform: translateY(3px);
  box-shadow: none;
}
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="hud" class="hidden">
  <div id="heart-counter">HEARTS: 0</div>
</div>

<div id="ui-layer">
  <div id="start-screen">
    <h1>VALENTINE'S<br>GAME</h1>
    <p>Tap to jump and<br>collect hearts! ‚ù§Ô∏è</p>
    <button class="pixel-btn" id="start-btn">TAP TO START</button>
  </div>

  <div id="end-screen" class="hidden">
    <p class="hearts-result"></p>
    <h2>WILL YOU BE<br>MY VALENTINE?</h2>
    <button id="yes-btn">YES! üíñ</button>
    <button id="no-btn">no</button>
  </div>

  <div id="result-screen" class="hidden"></div>
</div>

<script>
// ============ AUDIO ============
// Static WAV files served from same directory ‚Äî no JS generation, zero lag.

// Pre-create Audio elements with file references
function makePool(src, count) {
  const pool = [];
  for (let i = 0; i < count; i++) { const a = new Audio(src); a.preload = 'auto'; pool.push(a); }
  return pool;
}
const pools = {
  jump: makePool('sfx-jump.wav', 2),
  collect: makePool('sfx-collect.wav', 2),
  celebrate: makePool('sfx-celebrate.wav', 1)
};
const bgMusicEl = new Audio('bgm.wav');
bgMusicEl.loop = true; bgMusicEl.volume = 0.5; bgMusicEl.preload = 'auto';

// Unlock audio on first user gesture (required by iOS/mobile browsers)
let audioUnlocked = false;
function unlockAudio() {
  if (audioUnlocked) return;
  audioUnlocked = true;
  Object.values(pools).flat().forEach(a => {
    a.play().then(() => { a.pause(); a.currentTime = 0; }).catch(() => {});
  });
  bgMusicEl.play().then(() => { bgMusicEl.pause(); bgMusicEl.currentTime = 0; }).catch(() => {});
}
['touchstart','touchend','mousedown','click'].forEach(e =>
  document.addEventListener(e, unlockAudio, { capture: true, passive: true })
);

// Playback
const pidx = { jump: 0, collect: 0, celebrate: 0 };
function playSound(name) {
  const p = pools[name]; if (!p) return;
  const a = p[pidx[name] % p.length]; pidx[name]++;
  a.currentTime = 0; a.play().catch(() => {});
}
function sfxJump() { playSound('jump'); }
function sfxCollect() { playSound('collect'); }
function sfxCelebrate() { playSound('celebrate'); }
function startBgMusic() { bgMusicEl.currentTime = 0; bgMusicEl.play().catch(() => {}); }
function stopBgMusic() { bgMusicEl.pause(); bgMusicEl.currentTime = 0; }

// ============ CANVAS SETUP ============
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W, H, scale;

function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
  scale = Math.min(W, H) / 400;
}
resize();
window.addEventListener('resize', resize);

// ============ GAME STATE ============
const STATE = { START: 0, PLAYING: 1, ENDING: 2, END: 3, RESULT: 4 };
let state = STATE.START;
let heartsCollected = 0;
let totalHearts = 10;
let gameTimer = 0;
const GAME_DURATION = 5000;
// Scale scroll distance to screen width so it feels right on both phone and desktop
// Phone (~375px) -> ~750px, Desktop (~1400px) -> ~1200px
const SCROLL_DIST = Math.max(700, Math.min(1200, W * 1.8));
let lastTime = 0;

// ============ CHARACTER ============
const player = {
  x: 0, y: 0, vy: 0, groundY: 0,
  width: 28, height: 32,
  jumping: false, frame: 0, frameTimer: 0,
  eyeBlink: 0
};

// ============ HEARTS ============
let hearts = [];
let particles = [];

// ============ CLOUDS ============
let clouds = [];
function initClouds() {
  clouds = [];
  for (let i = 0; i < 6; i++) {
    clouds.push({
      x: Math.random() * W * 1.5,
      y: 30 + Math.random() * (H * 0.35),
      w: 40 + Math.random() * 60,
      speed: 15 + Math.random() * 20,
      opacity: 0.3 + Math.random() * 0.3
    });
  }
}

// ============ GROUND ============
let groundOffset = 0;

// ============ CONFETTI ============
let confetti = [];

// ============ INIT / START ============
function initGame() {
  heartsCollected = 0;
  gameTimer = 0;
  player.x = W * 0.15;
  player.groundY = H - 80 * scale;
  player.y = player.groundY;
  player.vy = 0;
  player.jumping = false;
  player.frame = 0;
  hearts = [];
  particles = [];
  confetti = [];
  groundOffset = 0;
  initClouds();
  spawnHearts();
  updateHUD();
}

function spawnHearts() {
  hearts = [];
  // Use a fixed scroll distance so mobile and desktop feel the same pace
  const totalScrollDist = SCROLL_DIST;
  const startOffset = totalScrollDist * 0.08;
  const endOffset = totalScrollDist * 0.92;
  const spacing = (endOffset - startOffset) / totalHearts;
  for (let i = 0; i < totalHearts; i++) {
    const baseX = player.x + startOffset + i * spacing;
    const tier = Math.random();
    let yPos;
    if (tier < 0.35) yPos = player.groundY - 20 * scale;
    else if (tier < 0.7) yPos = player.groundY - 70 * scale;
    else yPos = player.groundY - 120 * scale;
    hearts.push({
      x: baseX + (Math.random() - 0.5) * 40,
      y: yPos,
      size: 14 * scale,
      alive: true,
      bobOffset: Math.random() * Math.PI * 2,
      popTimer: 0
    });
  }
}

function updateHUD() {
  document.getElementById('heart-counter').textContent = `HEARTS: ${heartsCollected}`;
}

// ============ DRAWING HELPERS ============
function drawPixelRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(Math.round(x), Math.round(y), Math.round(w), Math.round(h));
}

// Pre-render heart to an offscreen canvas (drawn once, stamped many times)
const heartCache = {};
function getHeartCanvas(size, color) {
  const key = size + color;
  if (heartCache[key]) return heartCache[key];
  const s = size / 8;
  const w = Math.ceil(s * 9), h = Math.ceil(s * 6);
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const hctx = c.getContext('2d');
  hctx.fillStyle = color;
  const rows = [
    [-3,-1,-2,-1,1,-1,2,-1],
    [-4,0,-3,0,-2,0,-1,0,0,0,1,0,2,0,3,0],
    [-4,1,-3,1,-2,1,-1,1,0,1,1,1,2,1,3,1],
    [-3,2,-2,2,-1,2,0,2,1,2,2,2],
    [-2,3,-1,3,0,3,1,3],
    [-1,4,0,4]
  ];
  const ox = 4 * s, oy = s;
  rows.forEach(row => {
    for (let i = 0; i < row.length; i += 2)
      hctx.fillRect(Math.round(ox + row[i]*s), Math.round(oy + row[i+1]*s), Math.ceil(s), Math.ceil(s));
  });
  heartCache[key] = { canvas: c, ox: ox, oy: oy };
  return heartCache[key];
}

function drawHeart(cx, cy, size, color) {
  const h = getHeartCanvas(size, color);
  ctx.drawImage(h.canvas, Math.round(cx - h.ox), Math.round(cy - h.oy));
}

function drawCharacter(x, y) {
  const s = scale * 1.2;
  const px = Math.round(x);
  const py = Math.round(y);

  // Body (pink rounded)
  drawPixelRect(px - 10*s, py - 24*s, 20*s, 24*s, '#ff9bc5');
  // Body highlight
  drawPixelRect(px - 8*s, py - 22*s, 4*s, 8*s, '#ffb8d8');

  // Eyes
  const blinkOpen = player.eyeBlink < 0.9;
  if (blinkOpen) {
    drawPixelRect(px - 6*s, py - 18*s, 4*s, 5*s, '#fff');
    drawPixelRect(px + 2*s, py - 18*s, 4*s, 5*s, '#fff');
    drawPixelRect(px - 4*s, py - 17*s, 2*s, 3*s, '#222');
    drawPixelRect(px + 4*s, py - 17*s, 2*s, 3*s, '#222');
  } else {
    drawPixelRect(px - 6*s, py - 16*s, 5*s, 2*s, '#222');
    drawPixelRect(px + 2*s, py - 16*s, 5*s, 2*s, '#222');
  }

  // Cheeks
  drawPixelRect(px - 10*s, py - 12*s, 4*s, 3*s, '#ff7eb3');
  drawPixelRect(px + 6*s, py - 12*s, 4*s, 3*s, '#ff7eb3');

  // Mouth (smile)
  drawPixelRect(px - 2*s, py - 8*s, 5*s, 2*s, '#c0507a');

  // Feet
  const bounce = player.jumping ? 0 : Math.sin(player.frame * 0.3) * 3 * s;
  drawPixelRect(px - 8*s, py + bounce, 6*s, 4*s, '#ff7eb3');
  drawPixelRect(px + 2*s, py - bounce, 6*s, 4*s, '#ff7eb3');

  // Heart antenna
  drawPixelRect(px, py - 30*s, 2*s, 6*s, '#c0507a');
  drawHeart(px + 1*s, py - 36*s, 8*s, '#ff6b9d');
}

function drawGround() {
  const groundTop = H - 60 * scale;
  // Main ground
  ctx.fillStyle = '#8bac0f';
  ctx.fillRect(0, groundTop, W, H - groundTop);
  // Dark edge
  ctx.fillStyle = '#6d8b0a';
  ctx.fillRect(0, groundTop, W, 4 * scale);
  // Grass tufts
  ctx.fillStyle = '#9bbc0f';
  const tileW = 24 * scale;
  const off = groundOffset % tileW;
  for (let x = -tileW + off; x < W + tileW; x += tileW) {
    ctx.fillRect(Math.round(x), groundTop - 3*scale, 8*scale, 3*scale);
  }
}

// Cache the sky gradient as an offscreen canvas (recreated on resize)
let skyCache = null;
let skyCacheH = 0;
function getSkyCanvas() {
  if (skyCache && skyCacheH === H) return skyCache;
  skyCache = document.createElement('canvas');
  skyCache.width = 1; skyCache.height = H;
  const sctx = skyCache.getContext('2d');
  const grad = sctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#b8d4ff');
  grad.addColorStop(0.6, '#e2eeff');
  grad.addColorStop(1, '#ffdef2');
  sctx.fillStyle = grad;
  sctx.fillRect(0, 0, 1, H);
  skyCacheH = H;
  return skyCache;
}

function drawBackground(dt) {
  ctx.drawImage(getSkyCanvas(), 0, 0, 1, H, 0, 0, W, H);

  // Clouds
  clouds.forEach(c => {
    if (state === STATE.PLAYING) c.x -= c.speed * dt;
    if (c.x + c.w < -20) { c.x = W + 40; c.y = 30 + Math.random() * (H*0.35); }
    ctx.fillStyle = `rgba(255,255,255,${c.opacity})`;
    const cw = c.w * scale * 0.5;
    const ch = cw * 0.5;
    roundRect(c.x, c.y, cw, ch, ch * 0.4);
  });
}

function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.fill();
}

// ============ PARTICLES ============
function spawnParticles(x, y) {
  for (let i = 0; i < 8; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 200,
      vy: (Math.random() - 0.5) * 200 - 80,
      life: 0.6,
      maxLife: 0.6,
      size: (3 + Math.random() * 4) * scale,
      color: Math.random() > 0.5 ? '#ff6b9d' : '#ffb3d0'
    });
  }
}

function spawnConfetti() {
  for (let i = 0; i < 80; i++) {
    confetti.push({
      x: W * 0.5 + (Math.random() - 0.5) * W * 0.3,
      y: -20 - Math.random() * H * 0.5,
      vx: (Math.random() - 0.5) * 100,
      vy: 80 + Math.random() * 200,
      size: (4 + Math.random() * 8) * scale,
      color: ['#ff6b9d','#ffb3d0','#ff9bc5','#c0507a','#fff','#ffd700'][Math.floor(Math.random()*6)],
      rot: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 8
    });
  }
}

// ============ UPDATE ============
function update(dt) {
  if (state === STATE.PLAYING) {
    gameTimer += dt * 1000;

    // Move world
    const speed = (SCROLL_DIST / (GAME_DURATION / 1000)) * dt;
    groundOffset -= speed;

    // Move hearts toward player
    hearts.forEach(h => { if (h.alive) h.x -= speed; });

    // Player physics
    if (player.jumping) {
      player.vy += 1800 * scale * dt;
      player.y += player.vy * dt;
      if (player.y >= player.groundY) {
        player.y = player.groundY;
        player.vy = 0;
        player.jumping = false;
      }
    }

    // Player animation
    player.frameTimer += dt;
    if (player.frameTimer > 0.08) { player.frame++; player.frameTimer = 0; }
    player.eyeBlink = (Math.sin(performance.now() * 0.003) + 1) * 0.5;
    if (player.eyeBlink > 0.95) player.eyeBlink = 1;
    else player.eyeBlink = 0;

    // Heart collision
    hearts.forEach(h => {
      if (!h.alive) return;
      const bobY = h.y + Math.sin(performance.now() * 0.004 + h.bobOffset) * 6 * scale;
      const dx = player.x - h.x;
      const dy = (player.y - 12*scale) - bobY;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < 30 * scale) {
        h.alive = false;
        heartsCollected++;
        updateHUD();
        sfxCollect();
        spawnParticles(h.x, bobY);
      }
    });

    // Timer check
    if (gameTimer >= GAME_DURATION) {
      state = STATE.ENDING;
      setTimeout(showEndScreen, 600);
    }
  }

  // Update particles
  particles = particles.filter(p => {
    p.life -= dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 300 * dt;
    return p.life > 0;
  });

  // Update confetti
  confetti.forEach(c => {
    c.x += c.vx * dt;
    c.y += c.vy * dt;
    c.rot += c.rotSpeed * dt;
  });
  confetti = confetti.filter(c => c.y < H + 50);
}

// ============ RENDER ============
function render() {
  // Only draw background on start/end screens (skip game objects)
  const playing = state === STATE.PLAYING || state === STATE.ENDING;
  const hasEffects = particles.length > 0 || confetti.length > 0;

  // Skip rendering entirely if nothing is animating on static screens
  if (!playing && !hasEffects && (state === STATE.START || state === STATE.END)) {
    // Just draw background once, then stop
    if (!render._bgDrawn || render._bgState !== state) {
      ctx.drawImage(getSkyCanvas(), 0, 0, 1, H, 0, 0, W, H);
      drawGround();
      render._bgDrawn = true;
      render._bgState = state;
    }
    return;
  }
  render._bgDrawn = false;

  ctx.drawImage(getSkyCanvas(), 0, 0, 1, H, 0, 0, W, H);
  drawGround();

  if (playing) {
    // Draw hearts
    hearts.forEach(h => {
      if (!h.alive) return;
      const bobY = h.y + Math.sin(performance.now() * 0.004 + h.bobOffset) * 6 * scale;
      drawHeart(h.x, bobY, h.size, '#ff6b9d');
    });

    // Draw character
    drawCharacter(player.x, player.y);
  }

  // Particles
  if (particles.length > 0) {
    particles.forEach(p => {
      ctx.globalAlpha = p.life / p.maxLife;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x | 0, p.y | 0, p.size, p.size);
    });
    ctx.globalAlpha = 1;
  }

  // Confetti ‚Äî batch by color to reduce state changes
  if (confetti.length > 0) {
    confetti.forEach(c => {
      ctx.fillStyle = c.color;
      ctx.fillRect((c.x - c.size/2) | 0, (c.y - c.size/4) | 0, c.size, c.size/2);
    });
  }
}

// ============ GAME LOOP ============
function loop(time) {
  const dt = Math.min((time - lastTime) / 1000, 0.05);
  lastTime = time;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

// ============ INPUT ============
function handleTap(e) {
  e.preventDefault();
  if (state === STATE.PLAYING && !player.jumping) {
    player.jumping = true;
    player.vy = -550 * scale;
    sfxJump();
  }
}

canvas.addEventListener('pointerdown', handleTap);

// ============ SCREENS ============
function showEndScreen() {
  state = STATE.END;
  stopBgMusic();
  document.getElementById('hud').classList.add('hidden');
  const endScreen = document.getElementById('end-screen');
  endScreen.classList.remove('hidden');
  document.getElementById('start-screen').classList.add('hidden');
  endScreen.querySelector('.hearts-result').textContent = `You collected ${heartsCollected} hearts!`;
}

document.getElementById('start-btn').addEventListener('click', () => {
  unlockAudio();
  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
  state = STATE.PLAYING;
  initGame();
  startBgMusic();
});

document.getElementById('yes-btn').addEventListener('click', () => {
  sfxCelebrate();
  spawnConfetti();
  setTimeout(spawnConfetti, 400);
  document.getElementById('end-screen').classList.add('hidden');
  const result = document.getElementById('result-screen');
  result.classList.remove('hidden');
  result.innerHTML = `
    <h2 style="color:#ff6b9d;text-shadow:2px 2px 0 #c0507a">YAY!</h2>
    <p style="color:#c0507a;font-size:clamp(10px,3vw,16px);margin-top:10px;text-shadow:1px 1px 0 rgba(255,255,255,0.5)">Happy Valentine's Day! üíñ</p>
    <button class="play-again-btn" onclick="location.reload()">PLAY AGAIN</button>
  `;
  state = STATE.RESULT;
  localStorage.setItem('valentine_yes', 'true');
});

// NO button - always dodges, can never be clicked
const noBtn = document.getElementById('no-btn');
const yesBtn = document.getElementById('yes-btn');
let noAttempts = 0;

function dodgeNo(e) {
  if (e) { e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation(); }
  noAttempts++;

  // Make YES button grow with each attempt
  const growScale = 1 + noAttempts * 0.08;
  yesBtn.style.transform = `scale(${growScale})`;
  yesBtn.style.animation = 'none';
  void yesBtn.offsetHeight; // reflow
  yesBtn.style.animation = 'yesPulse 0.6s ease-in-out infinite';

  // Teleport to a random spot, keeping it on screen
  const pad = 30;
  const nx = pad + Math.random() * (W - pad * 2 - 60);
  const ny = pad + Math.random() * (H - pad * 2 - 30);
  noBtn.style.position = 'fixed';
  noBtn.style.left = nx + 'px';
  noBtn.style.top = ny + 'px';
  noBtn.style.zIndex = '100';
  // Shrink it further each time (min 0.3)
  const shrink = Math.max(0.3, 1 - noAttempts * 0.08);
  noBtn.style.transform = `scale(${shrink})`;
}

// Block click entirely ‚Äî dodge happens on pointer/touch events only
noBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); });
// Desktop hover
noBtn.addEventListener('pointerenter', dodgeNo);
// Mobile tap ‚Äî touchstart fires before click so we dodge first
noBtn.addEventListener('touchstart', dodgeNo, { passive: false });
// Fallback for non-touch pointer devices
noBtn.addEventListener('pointerdown', dodgeNo);

// ============ BOOT ============
initClouds();
lastTime = performance.now();
requestAnimationFrame(loop);
</script>
</body>
</html>
